package com.epay.merchant.validator;

import com.epay.merchant.dao.LoginDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.model.request.MerchantLoginRequest;
import com.epay.merchant.util.ErrorConstants;
import com.sbi.epay.logging.utility.LoggerUtility;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.UUID;

import static com.epay.merchant.util.ErrorConstants.LOGIN_USER_NOT_FOUND_ERROR_MESSAGE;
import static com.epay.merchant.util.ErrorConstants.NOT_FOUND_ERROR_CODE;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MerchantLoginValidatorTest {

    @Mock
    private LoginDao loginDao;

    @Mock
    private CaptchaValidator captchaValidator;

    @Mock
    private ValidationValidator validationValidator;

    @Mock
    private LoggerUtility logger;

    @InjectMocks
    private MerchantLoginValidator merchantLoginValidator;

    private MerchantLoginRequest merchantLoginRequest;

    @BeforeEach
    void setUp() {
        merchantLoginRequest = new MerchantLoginRequest();
        merchantLoginRequest.setUserName("testUser");
        merchantLoginRequest.setPassword("testPassword");
        merchantLoginRequest.setCaptchaText("123456");
        merchantLoginRequest.setRequestId(UUID.randomUUID());
    }

    @Test
    void testValidateMerchantLoginRequest_Success() {
        when(loginDao.isMerchantUserExistsByUserNameAndPassword(anyString(), anyString())).thenReturn(true);

        assertDoesNotThrow(() -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));

        verify(captchaValidator, times(1)).captchaValueValidation(any(), any());
        verify(loginDao, times(1)).isMerchantUserExistsByUserNameAndPassword(anyString(), anyString());
        verify(validationValidator, times(1)).validatedMerchantUser(anyString());
    }

    @Test
    void testValidateMerchantLoginRequest_UserNotFound() {
        when(loginDao.isMerchantUserExistsByUserNameAndPassword(anyString(), anyString())).thenReturn(false);

        Exception exception = assertThrows(RuntimeException.class, () -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));

        assertTrue(exception.getMessage().contains(LOGIN_USER_NOT_FOUND_ERROR_MESSAGE));

        verify(captchaValidator, times(1)).captchaValueValidation(any(), any());
        verify(loginDao, times(1)).isMerchantUserExistsByUserNameAndPassword(anyString(), anyString());
    }

    @Test
    void testValidateMandatoryFields_AllFieldsPresent() {
        assertDoesNotThrow(() -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));
    }

    @Test
    void testValidateMandatoryFields_MissingUserName() {
        merchantLoginRequest.setUserName(null);

        Exception exception = assertThrows(RuntimeException.class, () -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));

        assertTrue(exception.getMessage().contains(ErrorConstants.USER_NAME));
    }

    @Test
    void testIsUserExist_UserExists() {
        when(loginDao.isMerchantUserExistsByUserNameAndPassword(anyString(), anyString())).thenReturn(true);

        assertDoesNotThrow(() -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));
    }

    @Test
    void testIsUserExist_UserNotExists() {
        when(loginDao.isMerchantUserExistsByUserNameAndPassword(anyString(), anyString())).thenReturn(false);

        Exception exception = assertThrows(RuntimeException.class, () -> merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest));

        assertTrue(exception.getMessage().contains(LOGIN_USER_NOT_FOUND_ERROR_MESSAGE));
    }
}





package com.epay.merchant.validator;

import com.epay.merchant.dao.LoginDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.model.request.MerchantLoginRequest;
import com.epay.merchant.util.ErrorConstants;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.ArrayList;

import static com.epay.merchant.util.ErrorConstants.*;

/**
 * Class Name: MerchantLoginValidator
 * *
 * Description:  MerchantLoginValidator is responsible for validating the merchant login request,
 * including mandatory fields, user existence, and captcha.
 * *
 * Author: Ravi Rathore
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Component
@RequiredArgsConstructor
public class MerchantLoginValidator extends BaseValidator {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    private final LoginDao loginDao;
    private final CaptchaValidator captchaValidator;
    private final ValidationValidator validationValidator;

    /**
     * Validates the merchant login request, including mandatory fields,user existence and captcha validation
     *
     * @param merchantLoginRequest MerchantLoginRequest The login request to validate.
     */
    public void validateMerchantLoginRequest(MerchantLoginRequest merchantLoginRequest) {
        logger.debug("Merchant validation start for {}", merchantLoginRequest);
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(merchantLoginRequest);
        logger.debug("Mandatory validation completed for {}", merchantLoginRequest);
        captchaValidator.captchaValueValidation(merchantLoginRequest.getRequestId(), merchantLoginRequest.getCaptchaText());
        logger.debug("captcha validation completed for {}", merchantLoginRequest);
        isUserExist(merchantLoginRequest);
        logger.debug("user check validation completed for {}", merchantLoginRequest);
        validationValidator.validatedMerchantUser(merchantLoginRequest.getUserName());
        logger.debug("user status check completed for {}", merchantLoginRequest);
    }

    /**
     * Validates the all the mandatory fields in the merchantLoginRequest
     *
     * @param merchantLoginRequest MerchantLoginRequest
     */
    private void validateMandatoryFields(MerchantLoginRequest merchantLoginRequest) {
        checkMandatoryField(merchantLoginRequest.getUserName(), USER_NAME);
        checkMandatoryField(merchantLoginRequest.getPassword(), ErrorConstants.PSW);
        checkMandatoryField(merchantLoginRequest.getCaptchaText(), CAPTCHA_TEXT);
        checkMandatoryField(String.valueOf(merchantLoginRequest.getRequestId()), ErrorConstants.REQUEST_ID);
        throwIfErrors();
    }

    /**
     * Validates if the user exists based on the provided login request
     *
     * @param merchantLoginRequest MerchantLoginRequest
     */
    private void isUserExist(MerchantLoginRequest merchantLoginRequest) {
        boolean merchantUserExistsByUserNameAndPassword = loginDao.isMerchantUserExistsByUserNameAndPassword(merchantLoginRequest.getUserName(), merchantLoginRequest.getPassword());
        if (!merchantUserExistsByUserNameAndPassword) {
            errorDtoList.add(ErrorDto.builder().errorCode(NOT_FOUND_ERROR_CODE).errorMessage(LOGIN_USER_NOT_FOUND_ERROR_MESSAGE).build());
        }
        throwIfErrors();
    }


}
