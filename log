package com.epay.merchant.validator;


import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.MerchantBankDao;
import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantBankAccountDto;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.AdminServicesClient;
import com.epay.merchant.model.request.MerchantBankAccountApprovalRequest;
import com.epay.merchant.model.request.MerchantBankAccountRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.EPayIdentityUtil;
import com.epay.merchant.util.EncryptionDecryptionUtil;
import com.epay.merchant.util.enums.AccountType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;

import static com.epay.merchant.util.ErrorConstants.*;
import static com.epay.merchant.util.MerchantConstant.RESPONSE_FAILURE;
/**
 * Class Name: MerchantBankAccountValidator
 * *
 * Description: MerchantBankAccountValidator is responsible for validating the bank account details of a merchant.
 * It checks whether the account number, bank name, and other related information are valid.
 * *
 * Author: Ranu Jain
 * Copyright (c) 2024 [State Bank of India]
 * ALl rights reserved
 * *
 * Version: 1.0
 */
@RequiredArgsConstructor
@Component
public class MerchantBankAccountValidator extends BaseValidator {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantBankDao merchantBankDao;
    private final MerchantInfoDao merchantInfoDao;
    private final AdminServicesClient adminServicesClient;
    private final MerchantConfig merchantConfig;

    /**
     * Validate merchant account request
     * @param merchantBankAccountRequest MerchantBankAccountRequest
     * @param isCreate boolean
     */
    public void validateMerchantAccountRequest(MerchantBankAccountRequest merchantBankAccountRequest, boolean isCreate) {
        logger.debug("Merchant bank account details validation start for {}", merchantBankAccountRequest);
        errorDtoList = new ArrayList<>();
        validatedMandatoryFields(merchantBankAccountRequest);
        validateFieldValue(merchantBankAccountRequest);
        validateMId(merchantBankAccountRequest.getMId());
        if (isCreate) {
            validateAccountUniqueIdentifier(merchantBankAccountRequest);
        } else {
            validateAccountUniqueIdentifierForUpdate(merchantBankAccountRequest);
        }
        validateBankDetails(merchantBankAccountRequest);
        logger.debug("Merchant bank account details validation completed for {}", merchantBankAccountRequest);
    }

    /**
     * Validate merchant account approval request
     * @param merchantBankAccountApprovalRequest MerchantBankAccountApprovalRequest
     */
    public void validateMerchantAccountApprovalRequest(MerchantBankAccountApprovalRequest merchantBankAccountApprovalRequest) {
        logger.debug("Merchant bank account approval validation start for {}", merchantBankAccountApprovalRequest);
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(merchantBankAccountApprovalRequest);
        validateMId(merchantBankAccountApprovalRequest.getMId());
        validateAccountUniqueIdentifier(merchantBankAccountApprovalRequest.getAccountUniqueIdentifier());
    }

    public void validateMId(String mId) {
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        List<MerchantInfoDto> merchantInfoForMerchantUser = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);
        List<String> validMIds = merchantInfoForMerchantUser.stream().filter(m -> MerchantStatus.ACTIVE.name().equalsIgnoreCase(m.getStatus())).map(MerchantInfoDto::getMId).toList();
        if (validMIds.contains(mId)) {
            return;
        }
        throw new ValidationException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, MID, MID_ACCESS));
    }

    private void validateFieldValue(MerchantBankAccountRequest merchantBankAccountRequest) {
        validateFieldValue(merchantBankAccountRequest.getAccountType(), List.of(AccountType.SAVING.name(), AccountType.CURRENT.name()), ACCOUNT_TYPE);
        throwIfErrors();
        try {
            EncryptionDecryptionUtil.decryptValue(merchantConfig.getDecryptionKey(), merchantBankAccountRequest.getAccountNumber());
        } catch (Exception e) {
            throw new ValidationException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, ACCOUNT_NUMBER, DECRYPTION_FAILED));
        }
    }

    private void validatedMandatoryFields(MerchantBankAccountRequest merchantBankAccountRequest) {
        checkMandatoryField(merchantBankAccountRequest.getBankName(), BANK_NAME);
        checkMandatoryField(merchantBankAccountRequest.getBranchName(), BRANCH_NAME);
        checkMandatoryField(merchantBankAccountRequest.getIfscCode(), IFSC_CODE);
        checkMandatoryField(merchantBankAccountRequest.getAccountType(), ACCOUNT_TYPE);
        checkMandatoryField(merchantBankAccountRequest.getAccountNumber(), ACCOUNT_NUMBER);
        checkMandatoryField(merchantBankAccountRequest.getAccountHolderName(), ACCOUNT_HOLDER_NAME);
        checkMandatoryField(merchantBankAccountRequest.getAccountUniqueIdentifier(), ACCOUNT_UNIQUE_IDENTIFIER);
        checkMandatoryField(merchantBankAccountRequest.getMId(), MID);
        throwIfErrors();
    }

    private void validateMandatoryFields(MerchantBankAccountApprovalRequest merchantBankAccountApprovalRequest) {
        checkMandatoryField(merchantBankAccountApprovalRequest.getAccountName(), ACCOUNT_HOLDER_NAME);
        checkMandatoryField(merchantBankAccountApprovalRequest.getMId(), MID);
        checkMandatoryField(merchantBankAccountApprovalRequest.getAccountUniqueIdentifier(), ACCOUNT_UNIQUE_IDENTIFIER);
        if(!merchantBankAccountApprovalRequest.isApproved()) {
            checkMandatoryField(merchantBankAccountApprovalRequest.getRemarks(), REMARK);
        }
    }

    private void validateBankDetails(MerchantBankAccountRequest merchantBankAccountRequest) {
        MerchantResponse<String> response = adminServicesClient.validateBankDetails(merchantBankAccountRequest.getBankName(), merchantBankAccountRequest.getBranchName(), merchantBankAccountRequest.getIfscCode());
        if (response.getStatus() == RESPONSE_FAILURE) {
            throw new ValidationException(response.getErrors());
        }
    }

    private void validateAccountUniqueIdentifier(MerchantBankAccountRequest merchantBankAccountRequest) {
        boolean existByAccountUniqueIdentifier = merchantBankDao.isExistByAccountUniqueIdentifier(merchantBankAccountRequest.getAccountUniqueIdentifier());
        if (existByAccountUniqueIdentifier) {
            errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, "AccountUniqueIdentifier")).build());
        }
        boolean existByAccountNumber = merchantBankDao.isExistByAccountNumber(merchantBankAccountRequest.getAccountNumber());
        if (existByAccountNumber) {
            errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, ACCOUNT_NUMBER)).build());
        }
        throwIfErrors();
    }

    private void validateAccountUniqueIdentifier(String uniqueIdentifier) {
        boolean existByAccountUniqueIdentifier = merchantBankDao.isExistByAccountUniqueIdentifier(uniqueIdentifier);
        if(!existByAccountUniqueIdentifier) {
            errorDtoList.add(ErrorDto.builder().errorCode(NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, ACCOUNT_UNIQUE_IDENTIFIER)).build());
        }
        throwIfErrors();
    }

    private void validateAccountUniqueIdentifierForUpdate(MerchantBankAccountRequest merchantBankAccountRequest) {
        MerchantBankAccountDto dbMerchantBankAccount = merchantBankDao.getAccountByAccountUniqueIdentifier(merchantBankAccountRequest.getAccountUniqueIdentifier());
        if (!merchantBankAccountRequest.getAccountNumber().equalsIgnoreCase(dbMerchantBankAccount.getAccountNumber())) {
            boolean existByAccountNumber = merchantBankDao.isExistByAccountNumber(merchantBankAccountRequest.getAccountNumber());
            if (existByAccountNumber) {
                errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, ACCOUNT_NUMBER)).build());
            }
            throwIfErrors();
        }
    }

}
