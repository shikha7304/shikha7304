import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import com.sbiepay.merchant.dao.*;
import com.sbiepay.merchant.dto.*;
import com.sbiepay.merchant.exception.MerchantException;
import com.sbiepay.merchant.mapper.MerchantMapper;
import com.sbiepay.merchant.model.request.*;
import com.sbiepay.merchant.model.response.*;
import com.sbiepay.merchant.util.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.UUID;

@ExtendWith(MockitoExtension.class)
class MerchantUserServiceTest {

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    private MerchantUserDao merchantUserDao;

    @Mock
    private MerchantUserRoleDao merchantUserRoleDao;

    @Mock
    private MerchantUserValidator merchantUserValidator;

    @Mock
    private MerchantMapper merchantMapper;

    @Mock
    private CSVGenerator csvGenerator;

    @InjectMocks
    private MerchantUserService merchantUserService;

    private MerchantUserDto merchantUserDto;
    private MerchantUserRequest merchantUserRequest;
    private MerchantUserResponse merchantUserResponse;
    private MerchantUserStatusRequest merchantUserStatusRequest;
    private MerchantUserAssignedMIdsResponse assignedMIdsResponse;
    private UserMenuPermissionEntityResponse userMenuResponse;

    @BeforeEach
    void setUp() {
        merchantUserDto = new MerchantUserDto();
        merchantUserDto.setId(UUID.randomUUID());
        merchantUserDto.setUserName("testUser");
        merchantUserDto.setRole("ADMIN");

        merchantUserRequest = new MerchantUserRequest();
        merchantUserRequest.setUserName("testUser");

        merchantUserResponse = new MerchantUserResponse();
        merchantUserResponse.setUserName("testUser");

        merchantUserStatusRequest = new MerchantUserStatusRequest();
        merchantUserStatusRequest.setUserName("testUser");
        merchantUserStatusRequest.setUserStatus("ACTIVE");

        assignedMIdsResponse = new MerchantUserAssignedMIdsResponse();
        userMenuResponse = new UserMenuPermissionEntityResponse();
    }

    @Test
    void testGetMerchantUserAccess_Success() {
        when(merchantUserDao.getByUserName(anyString(), any())).thenReturn(merchantUserDto);
        when(merchantUserDao.getRoleNameByRoleId(anyString())).thenReturn("Admin");
        when(merchantUserDao.getUserMenuPermission(any())).thenReturn(List.of(userMenuResponse));

        MerchantResponse<MerchantUserAccessResponse> response = merchantUserService.getMerchantUserAccess();

        assertNotNull(response);
        assertEquals("SUCCESS", response.getStatus());
        verify(merchantUserDao, times(1)).getByUserName(anyString(), any());
    }

    @Test
    void testGetMerchantUserAccess_UserNotFound() {
        when(merchantUserDao.getByUserName(anyString(), any())).thenReturn(null);

        Exception exception = assertThrows(MerchantException.class, () -> {
            merchantUserService.getMerchantUserAccess();
        });

        assertTrue(exception.getMessage().contains("UserName"));
    }

    @Test
    void testCreateMerchantUser_Success() {
        doNothing().when(merchantUserValidator).validateMerchantUserRequest(any(), eq(true));
        when(merchantMapper.mapMerchantUserRequestToMerchantUserDto(any())).thenReturn(merchantUserDto);
        when(merchantUserDao.saveMerchantUser(any(), anyString())).thenReturn(merchantUserDto);
        when(merchantMapper.mapMerchantUserDtoToResponse(any())).thenReturn(merchantUserResponse);

        MerchantResponse<MerchantUserResponse> response = merchantUserService.createMerchantUser(merchantUserRequest);

        assertNotNull(response);
        assertEquals("SUCCESS", response.getStatus());
        verify(merchantUserValidator, times(1)).validateMerchantUserRequest(any(), eq(true));
    }

    @Test
    void testUpdateMerchantUser_Success() {
        doNothing().when(merchantUserValidator).validateMerchantUserRequest(any(), eq(false));
        when(merchantMapper.mapMerchantUserRequestToMerchantUserDto(any())).thenReturn(merchantUserDto);
        when(merchantUserDao.updateMerchantUser(any(), eq(false))).thenReturn(merchantUserDto);
        when(merchantMapper.mapMerchantUserDtoToResponse(any())).thenReturn(merchantUserResponse);

        MerchantResponse<MerchantUserResponse> response = merchantUserService.updateMerchantUser(merchantUserRequest);

        assertNotNull(response);
        assertEquals("SUCCESS", response.getStatus());
        verify(merchantUserValidator, times(1)).validateMerchantUserRequest(any(), eq(false));
    }

    @Test
    void testUpdateUserStatus_Success() {
        doNothing().when(merchantUserValidator).validateUpdateUserStatus(any());
        when(merchantUserDao.updateUserStatusByUserName(anyString(), anyString(), anyString())).thenReturn(merchantUserResponse);

        MerchantResponse<MerchantUserResponse> response = merchantUserService.updateUserStatus(merchantUserStatusRequest);

        assertNotNull(response);
        assertEquals("SUCCESS", response.getStatus());
        verify(merchantUserValidator, times(1)).validateUpdateUserStatus(any());
    }

    @Test
    void testSearchMerchantUsers_Success() {
        Page<MerchantUserDto> mockPage = mock(Page.class);
        when(mockPage.getContent()).thenReturn(List.of(merchantUserDto));
        when(mockPage.getTotalElements()).thenReturn(1L);
        when(merchantUserDao.findMerchantUsers(any(Pageable.class), any())).thenReturn(mockPage);
        when(merchantMapper.mapMerchantUserDTOListToResponseList(any())).thenReturn(List.of(merchantUserResponse));

        MerchantResponse<MerchantUserResponse> response = merchantUserService.searchMerchantUsers(mock(Pageable.class), new MerchantUserSearchRequest());

        assertNotNull(response);
        assertEquals(1, response.getTotal());
    }

    @Test
    void testAssignedMIdsToUser_Success() {
        when(merchantUserDao.getByUserName(anyString(), any())).thenReturn(merchantUserDto);
        doNothing().when(merchantUserValidator).validatePostMapping(anyString(), any(), anyList());
        when(merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(anyString())).thenReturn(List.of());

        MerchantResponse<String> response = merchantUserService.assignedMIdsToUser("testUser", List.of("MID123"));

        assertNotNull(response);
        assertEquals("MIds is assigned Successfully", response.getData().get(0));
    }

    @Test
    void testAssignedMenuAccessToUser_Success() {
        when(merchantUserDao.getByUserName(anyString(), any())).thenReturn(merchantUserDto);
        doNothing().when(merchantUserValidator).validateMenuPostMapping(anyString(), any(), anyList());
        when(merchantUserDao.getUserMenuPermission(any())).thenReturn(List.of(userMenuResponse));

        MerchantResponse<String> response = merchantUserService.assignedMenuAccessToUser("testUser", List.of("MENU123"));

        assertNotNull(response);
        assertEquals("Menus is assigned Successfully", response.getData().get(0));
    }
}







public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantUserRoleDao merchantUserRoleDao;
    private final MerchantUserValidator merchantUserValidator;
    private final MerchantMapper merchantMapper;
    private final CSVGenerator csvGenerator;
    protected static final List<String> USER_DOWNLOAD_HEADER = List.of("User Id", "Name", "Email", "Mobile No.", "User Type", "Status", "Creation Date");
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private static List<String> getNewMenuMappingList(List<String> menuList, List<UserMenuPermissionEntityResponse> assignedMenus) {
        List<String> newMappedMenu = new ArrayList<>();
        for (String menu : menuList){
            boolean mIdFound = false;
            for (UserMenuPermissionEntityResponse assignedMenu : assignedMenus) {
                if (menu.equalsIgnoreCase(assignedMenu.getMenuCode())) {
                   mIdFound = true;
                    break;
                }
            }
            if(!mIdFound){
                newMappedMenu.add(menu);
            }
        }
        return newMappedMenu;
    }

    private static List<String> getNewMIdMappingList(List<String> mIds, List<MerchantInfoDto> assignedMIds) {
        List<String> newMappedMIds = new ArrayList<>();
        for (String mId : mIds) {
            boolean mIdFound = false;
            for (MerchantInfoDto assignedMId : assignedMIds) {
                if (mId.equalsIgnoreCase(assignedMId.getMId())) {
                    mIdFound = true;
                    break;
                }
            }
            if (!mIdFound) {
                newMappedMIds.add(mId);
            }
        }
        return newMappedMIds;
    }
public MerchantResponse<MerchantUserAccessResponse> getMerchantUserAccess() {
        log.info("Fetching merchant user access for the logged-in user");
        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        merchantUserDto.setRoleName(merchantUserDao.getRoleNameByRoleId(merchantUserDto.getRole()));
        if (ObjectUtils.isEmpty(merchantUserDto)) {
            log.error("No active merchant user found for username: {}", userName);
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName"));
        }

        // Step 3 : Get Merchant Permission Info of Logged in Merchant User
        List<UserMenuPermissionEntityResponse> userAccess = merchantUserDao.getUserMenuPermission(merchantUserDto.getId());

        // Step 4 : Build Merchant User Access Response
        MerchantUserAccessResponse merchantUserAccessResponse = MerchantUserAccessResponse.builder().userInfo(merchantUserDto).userAccess(userAccess).build();

        log.info("Successfully fetched merchant user access for {}", userName);
        // Step 4 : Building the response
        return MerchantResponse.<MerchantUserAccessResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(merchantUserAccessResponse)).build();
    }
public MerchantResponse<MerchantUserResponse> createMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Creating a new merchant user");
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, true);
        log.info("Merchant user created successfully with username: {}", merchantUserRequest.getUserName());
        return saveMerchantUser(merchantUserRequest, false, false);
    }

    /**
     * Updates an existing merchant user's details based on the provided request.
     * Validates the request before updating the user data.
     *
     * @param merchantUserRequest Request object containing updated user details.
     * @return MerchantResponse containing the updated user's details.
     */
    public MerchantResponse<MerchantUserResponse> updateMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Updating merchant user details for username: {}", merchantUserRequest.getUserName());
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, false);

        log.info("Merchant user updated successfully for username: {}", merchantUserRequest.getUserName());

        return saveMerchantUser(merchantUserRequest, false, true);
    }

    /**
     * Updates the profile of the logged-in merchant user.
     * Validates the request before performing the update.
     *
     * @param merchantUserRequest Request object containing profile details.
     * @return MerchantResponse containing the updated profile information.
     */
    public MerchantResponse<MerchantUserResponse> updateMerchantUserProfile(MerchantUserRequest merchantUserRequest) {
        log.info("Updating profile for merchant user: {}", merchantUserRequest.getUserName());
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserProfile(merchantUserRequest);

        log.info("Merchant user profile updated successfully for username: {}", merchantUserRequest.getUserName());
        return saveMerchantUser(merchantUserRequest, true, true);
    }

    /**
     * Update Merchant User Status
     *
     * @param merchantUserStatusRequest MerchantUserStatusRequest
     * @return MerchantResponse<MerchantUserResponse> - Response containing updated user information
     */
    public MerchantResponse<MerchantUserResponse> updateUserStatus(MerchantUserStatusRequest merchantUserStatusRequest) {
        log.info("Updating status Request {}", merchantUserStatusRequest);
        merchantUserValidator.validateUpdateUserStatus(merchantUserStatusRequest);
        MerchantUserResponse merchantUserResponse = merchantUserDao.updateUserStatusByUserName(merchantUserStatusRequest.getUserName(), merchantUserStatusRequest.getUserStatus(), merchantUserStatusRequest.getRemark());
        log.info("User status updated successfully for username: {}", merchantUserStatusRequest.getUserName());
        return MerchantResponse.<MerchantUserResponse>builder().data(List.of(merchantUserResponse)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).total(1L).build();
    }

    /**
     * Saves the merchant user details to the database.
     * Handles both new user creation and user updates.
     *
     * @param merchantUserRequest Request object containing user details.
     * @param isProfileUpdate     Indicates if the update is specific to a profile.
     * @param isUpdate            Indicates if the operation is an update.
     * @return MerchantResponse containing the saved user's details.
     */
    private MerchantResponse<MerchantUserResponse> saveMerchantUser(MerchantUserRequest merchantUserRequest, boolean isProfileUpdate, boolean isUpdate) {
        log.info("{} merchant user with username: {}", isUpdate ? "Updating" : "Creating", merchantUserRequest.getUserName());
        //Step 1 : Save the Merchant User Data in DB
        MerchantUserDto merchantUserDto = merchantMapper.mapMerchantUserRequestToMerchantUserDto(merchantUserRequest);
        if (isUpdate) {
            merchantUserDto = merchantUserDao.updateMerchantUser(merchantUserDto, isProfileUpdate);
        } else {
            merchantUserDto = merchantUserDao.saveMerchantUser(merchantUserDto, StringUtils.EMPTY);
        }
        //Step 2 : Build MerchantResponse and return to caller
        MerchantUserResponse merchantUserResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        merchantUserResponse.setRoleName(merchantUserDao.getUserRoleName(merchantUserDto.getRole()));
        log.info("completed saveMerchantUser for username: {}", merchantUserRequest.getUserName());
        return MerchantResponse.<MerchantUserResponse>builder().data(List.of(merchantUserResponse)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).build();
    }

    /**
     * Searches for merchant users based on the provided search criteria.
     * Returns a paginated list of matching merchant users.
     *
     * @param merchantUserSearchRequest Request object containing search criteria.
     * @return MerchantResponse containing the search results.
     */
    public MerchantResponse<MerchantUserResponse> searchMerchantUsers(Pageable pageable, MerchantUserSearchRequest merchantUserSearchRequest) {
        log.info("Search merchant users Request {}", merchantUserSearchRequest);
        Page<MerchantUserDto> merchantUsers = merchantUserDao.findMerchantUsers(pageable, merchantUserSearchRequest);
        List<MerchantUserResponse> merchantUserResponseList = merchantMapper.mapMerchantUserDTOListToResponseList(merchantUsers.getContent());
        log.info("Returning list of merchant users {}", merchantUserResponseList);
        return MerchantResponse.<MerchantUserResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(merchantUserResponseList).count(merchantUsers.stream().count()).total(merchantUsers.getTotalElements()).build();
    }
  public MerchantResponse<MerchantUserAssignedMIdsResponse> getAssignedUnAssignedMIdsOfUser(String userName) {
        log.info("Fetching AssignedUnAssignedMIdsOfUser for userName: {} ",userName);
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatedMappingRequest(userName, merchantUser);

        //Step 3  : Get Assigned MIds
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);

        //Step 4  : Get UnAssigned MIds from ParentUser
        List<MerchantInfoResponse> unAssignedMerchantInfo = getParentAssignedMIds(merchantUser, assignedMIds);

        //Step 5  : Build MerchantUserAssignedMIdsResponse
        List<MerchantInfoResponse> assignedMerchantInfo = merchantMapper.mapMerchantInfoDTOListToResponseList(assignedMIds);
        MerchantUserAssignedMIdsResponse userAssignedMIdsResponse = MerchantUserAssignedMIdsResponse.builder().assignedMIds(assignedMerchantInfo).unAssignedMIds(unAssignedMerchantInfo).build();

        log.info("Returning MerchantUserAssignedMIdsResponse for userName: {} ",userName);
        //Step 6 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<MerchantUserAssignedMIdsResponse>builder().data(List.of(userAssignedMIdsResponse)).build();
    }

    /**
     * Assigns a list of MIDs to the specified user.
     * Validates the request and updates the database with the new mappings.
     *
     * @param userName Username of the merchant user.
     * @param mIds     List of MIDs to be assigned to the user.
     * @return MerchantResponse confirming the successful assignment.
     */
    public MerchantResponse<String> assignedMIdsToUser(String userName, List<String> mIds) {
        log.info("Fetching list of MIDs assigned to the userName: {},mIds: {} ",userName,mIds);
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatePostMapping(userName, merchantUser, mIds);

        //Step 3  : Build Remove and new Assigned MIds list from current data
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);
        List<String> removedMIds = assignedMIds.stream().map(MerchantInfoDto::getMId).filter(mId -> !mIds.contains(mId)).toList();
        List<String> newMappedMIds = getNewMIdMappingList(mIds, assignedMIds);

        //Step 4 : Update the data in DB as per remove and new MIDs list
        merchantUserDao.assignedMIds(newMappedMIds, removedMIds, merchantUser.getId());

        log.info("Completed assignedMIdsToUser for userName: {},mIds: {} ",userName,mIds);
        //Step 5 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<String>builder().data(List.of("MIds is assigned Successfully")).build();
    }

    /**
     * Retrieves the assigned and unassigned menus for a specific user.
     *
     * @param userName The username of the merchant user.
     * @return A response containing assigned and unassigned menus of the user.
     */
    public MerchantResponse<MerchantUserAssignedMenusResponse> getAssignedUnAssignedMenuAccessOfUser(String userName) {
        log.info("Starting to fetch assigned and unassigned menu access for user: {}", userName);
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatedMappingRequest(userName, merchantUser);

        //Step 3  : Get Assigned Menus
        List<UserMenuPermissionEntityResponse> assignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getId());

        //Step 4  : Get UnAssigned Menus from ParentUser
        List<UserMenuPermissionEntityResponse> unAssignedMenus = getParentAssignedMenus(merchantUser, assignedMenus);

        //Step 5  : Build MerchantUserAssignedMenusResponse
        MerchantUserAssignedMenusResponse userAssignedMenusResponse = MerchantUserAssignedMenusResponse.builder().assignedMenus(assignedMenus).unAssignedMenus(unAssignedMenus).build();
        log.info("Successfully fetched assigned and unassigned menus for username: {}", userName);
        //Step 6 :  Build MerchantResponse Object of MerchantUserAssignedMenusResponse
        return MerchantResponse.<MerchantUserAssignedMenusResponse>builder().data(List.of(userAssignedMenusResponse)).build();
    }

    /**
     * Assigns a list of menus to a user while removing the previously assigned menus not in the new list.
     *
     * @param userName The username of the merchant user.
     * @param menuList The list of menu codes to assign to the user.
     * @return A response indicating successful assignment of menus.
     */
    public MerchantResponse<String> assignedMenuAccessToUser(String userName, List<String> menuList) {
        log.info("Starting to assign menu access for username: {}", userName);
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validateMenuPostMapping(userName, merchantUser, menuList);

        //Step 3  : Build Remove and new Assigned Menu list from current data
        List<UserMenuPermissionEntityResponse> assignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getId());
        List<UUID> removedMenus = assignedMenus.stream().filter(assignedMenu -> !menuList.contains(assignedMenu.getMenuCode())).map(UserMenuPermissionEntityResponse::getMenuId).toList();
        List<String> newMappedMenus = getNewMenuMappingList(menuList, assignedMenus);

        //Step 4 : Update the data in DB as per remove and new Menu list
        merchantUserDao.assignedMenus(newMappedMenus, removedMenus, merchantUser.getId());
        log.info("Menu access assigned successfully for username: {}", userName);
        //Step 5 :  Build MerchantResponse
        return MerchantResponse.<String>builder().data(List.of("Menus is assigned Successfully")).build();
    }

    /**
     * Retrieves the unassigned MIDs for a specified user by comparing the parent's
     * accessible MIDs with the user's currently assigned MIDs.
     *
     * @param merchantUser Merchant user details.
     * @param assignedMIds List of currently assigned MIDs for the user.
     * @return List of unassigned MIDs available for the user.
     */
    private List<MerchantInfoResponse> getParentAssignedMIds(MerchantUserDto merchantUser, List<MerchantInfoDto> assignedMIds) {
        log.info("Fetching unassigned MIDs for user ID: {}", merchantUser.getId());
        List<MerchantInfoResponse> unAssignedMerchantInfo = new ArrayList<>();

        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            //Step 2: Get Parent Assigned MIDs List
            List<MerchantInfoDto> parentAssignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(merchantUser.getParentUserId());

            //Step 3: Remove Assigned MIDs List from Parent Assigned MIDs List
            parentAssignedMIds.removeAll(assignedMIds);
            if (CollectionUtils.isNotEmpty(parentAssignedMIds)) {
                unAssignedMerchantInfo.addAll(merchantMapper.mapMerchantInfoDTOListToResponseList(parentAssignedMIds));
            }
        }
        log.info("Successfully fetched unassigned MIDs for user ID: {}", merchantUser.getId());
        return unAssignedMerchantInfo;
    }

    /**
     * Retrieves the unassigned menus for a specified user by comparing the parent's
     * accessible menus with the user's currently assigned menus.
     *
     * @param merchantUser Merchant user details.
     * @param assignedMenus List of currently assigned menus for the user.
     * @return List of unassigned menus available for the user.
     */
    private List<UserMenuPermissionEntityResponse> getParentAssignedMenus(MerchantUserDto merchantUser, List<UserMenuPermissionEntityResponse> assignedMenus) {
        log.info("Fetching unassigned menus for user ID: {}", merchantUser.getId());
        List<UserMenuPermissionEntityResponse> unAssignedMerchantInfo = new ArrayList<>();

        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            //Step 2: Get Parent Assigned MIDs List
            List<UserMenuPermissionEntityResponse> parentAssignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getParentUserId());

            //Step 3: Remove Assigned MIDs List from Parent Assigned MIDs List
            parentAssignedMenus.removeAll(assignedMenus);
            for (UserMenuPermissionEntityResponse p : parentAssignedMenus) {
                boolean isFound = false;
                for (UserMenuPermissionEntityResponse a : assignedMenus) {
                    if (a.getMenuCode().equalsIgnoreCase(p.getMenuCode())) {
                        isFound = true;
                        break;
                    }
                }
                if(!isFound) {
                    unAssignedMerchantInfo.add(p);
                }
            }
        }
        log.info("Successfully fetched unassigned menus for user ID: {}", merchantUser.getId());
        return unAssignedMerchantInfo;
    }
