package com.epay.merchant.validator;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.MerchantBankDao;
import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantBankAccountDto;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.AdminServicesClient;
import com.epay.merchant.model.request.MerchantBankAccountApprovalRequest;
import com.epay.merchant.model.request.MerchantBankAccountRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.EPayIdentityUtil;
import com.epay.merchant.util.EncryptionDecryptionUtil;
import com.epay.merchant.util.enums.AccountType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.sbi.epay.logging.utility.LoggerUtility;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static com.epay.merchant.util.ErrorConstants.*;
import static com.epay.merchant.util.MerchantConstant.RESPONSE_FAILURE;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MerchantBankAccountValidatorTest {

    @Mock
    private MerchantBankDao merchantBankDao;

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    private AdminServicesClient adminServicesClient;

    @Mock
    private MerchantConfig merchantConfig;

    @Mock
    private LoggerUtility logger;

    @InjectMocks
    private MerchantBankAccountValidator validator;

    private MerchantBankAccountRequest request;
    private MerchantBankAccountApprovalRequest approvalRequest;

    @BeforeEach
    void setUp() {
        request = new MerchantBankAccountRequest();
        request.setBankName("SBI");
        request.setBranchName("Mumbai");
        request.setIfscCode("SBIN0001234");
        request.setAccountType(AccountType.SAVING.name());
        request.setAccountNumber("1234567890");
        request.setAccountHolderName("John Doe");
        request.setAccountUniqueIdentifier("UID123");
        request.setMId("MID123");

        approvalRequest = new MerchantBankAccountApprovalRequest();
        approvalRequest.setAccountName("John Doe");
        approvalRequest.setMId("MID123");
        approvalRequest.setAccountUniqueIdentifier("UID123");
        approvalRequest.setApproved(true);
    }

    @Test
    void testValidateMerchantAccountRequest_Create() {
        when(merchantBankDao.isExistByAccountUniqueIdentifier(anyString())).thenReturn(false);
        when(merchantBankDao.isExistByAccountNumber(anyString())).thenReturn(false);
        when(adminServicesClient.validateBankDetails(anyString(), anyString(), anyString()))
                .thenReturn(new MerchantResponse<>());

        assertDoesNotThrow(() -> validator.validateMerchantAccountRequest(request, true));
    }

    @Test
    void testValidateMerchantAccountRequest_Update() {
        MerchantBankAccountDto dbAccount = new MerchantBankAccountDto();
        dbAccount.setAccountNumber("9876543210");

        when(merchantBankDao.getAccountByAccountUniqueIdentifier(anyString())).thenReturn(dbAccount);
        when(merchantBankDao.isExistByAccountNumber(anyString())).thenReturn(false);

        assertDoesNotThrow(() -> validator.validateMerchantAccountRequest(request, false));
    }

    @Test
    void testValidateMerchantAccountApprovalRequest() {
        when(merchantBankDao.isExistByAccountUniqueIdentifier(anyString())).thenReturn(true);
        assertDoesNotThrow(() -> validator.validateMerchantAccountApprovalRequest(approvalRequest));
    }

    @Test
    void testValidateMerchantAccountApprovalRequest_InvalidUniqueIdentifier() {
        when(merchantBankDao.isExistByAccountUniqueIdentifier(anyString())).thenReturn(false);
        ValidationException exception = assertThrows(ValidationException.class,
                () -> validator.validateMerchantAccountApprovalRequest(approvalRequest));
        assertEquals(NOT_FOUND_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }

    @Test
    void testValidateMId_Valid() {
        when(merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(anyString()))
                .thenReturn(List.of(new MerchantInfoDto("MID123", MerchantStatus.ACTIVE.name())));

        assertDoesNotThrow(() -> validator.validateMId("MID123"));
    }

    @Test
    void testValidateMId_Invalid() {
        when(merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(anyString()))
                .thenReturn(List.of(new MerchantInfoDto("MID999", MerchantStatus.INACTIVE.name())));

        ValidationException exception = assertThrows(ValidationException.class, () -> validator.validateMId("MID123"));
        assertEquals(INVALID_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }

    @Test
    void testValidateFieldValue_InvalidDecryption() {
        when(merchantConfig.getDecryptionKey()).thenReturn("invalidKey");

        doThrow(new RuntimeException("Decryption failed"))
                .when(() -> EncryptionDecryptionUtil.decryptValue(anyString(), anyString()));

        ValidationException exception = assertThrows(ValidationException.class,
                () -> validator.validateMerchantAccountRequest(request, true));
        assertEquals(INVALID_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }

    @Test
    void testValidateBankDetails_InvalidResponse() {
        MerchantResponse<String> response = new MerchantResponse<>();
        response.setStatus(RESPONSE_FAILURE);
        response.setErrors(List.of(new ErrorDto(INVALID_ERROR_CODE, "Invalid bank details")));

        when(adminServicesClient.validateBankDetails(anyString(), anyString(), anyString())).thenReturn(response);

        ValidationException exception = assertThrows(ValidationException.class,
                () -> validator.validateMerchantAccountRequest(request, true));
        assertEquals(INVALID_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }

    @Test
    void testValidateAccountUniqueIdentifier_AlreadyExists() {
        when(merchantBankDao.isExistByAccountUniqueIdentifier(anyString())).thenReturn(true);
        when(merchantBankDao.isExistByAccountNumber(anyString())).thenReturn(true);

        ValidationException exception = assertThrows(ValidationException.class,
                () -> validator.validateMerchantAccountRequest(request, true));
        assertEquals(ALREADY_EXIST_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }

    @Test
    void testValidateAccountUniqueIdentifierForUpdate_AccountNumberChanged() {
        MerchantBankAccountDto dbAccount = new MerchantBankAccountDto();
        dbAccount.setAccountNumber("9876543210");

        when(merchantBankDao.getAccountByAccountUniqueIdentifier(anyString())).thenReturn(dbAccount);
        when(merchantBankDao.isExistByAccountNumber(anyString())).thenReturn(true);

        ValidationException exception = assertThrows(ValidationException.class,
                () -> validator.validateMerchantAccountRequest(request, false));
        assertEquals(ALREADY_EXIST_ERROR_CODE, exception.getErrors().get(0).getErrorCode());
    }
}





package com.epay.merchant.validator;


import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.MerchantBankDao;
import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantBankAccountDto;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.AdminServicesClient;
import com.epay.merchant.model.request.MerchantBankAccountApprovalRequest;
import com.epay.merchant.model.request.MerchantBankAccountRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.EPayIdentityUtil;
import com.epay.merchant.util.EncryptionDecryptionUtil;
import com.epay.merchant.util.enums.AccountType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;

import static com.epay.merchant.util.ErrorConstants.*;
import static com.epay.merchant.util.MerchantConstant.RESPONSE_FAILURE;
/**
 * Class Name: MerchantBankAccountValidator
 * *
 * Description: MerchantBankAccountValidator is responsible for validating the bank account details of a merchant.
 * It checks whether the account number, bank name, and other related information are valid.
 * *
 * Author: Ranu Jain
 * Copyright (c) 2024 [State Bank of India]
 * ALl rights reserved
 * *
 * Version: 1.0
 */
@RequiredArgsConstructor
@Component
public class MerchantBankAccountValidator extends BaseValidator {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantBankDao merchantBankDao;
    private final MerchantInfoDao merchantInfoDao;
    private final AdminServicesClient adminServicesClient;
    private final MerchantConfig merchantConfig;

    /**
     * Validate merchant account request
     * @param merchantBankAccountRequest MerchantBankAccountRequest
     * @param isCreate boolean
     */
    public void validateMerchantAccountRequest(MerchantBankAccountRequest merchantBankAccountRequest, boolean isCreate) {
        logger.debug("Merchant bank account details validation start for {}", merchantBankAccountRequest);
        errorDtoList = new ArrayList<>();
        validatedMandatoryFields(merchantBankAccountRequest);
        validateFieldValue(merchantBankAccountRequest);
        validateMId(merchantBankAccountRequest.getMId());
        if (isCreate) {
            validateAccountUniqueIdentifier(merchantBankAccountRequest);
        } else {
            validateAccountUniqueIdentifierForUpdate(merchantBankAccountRequest);
        }
        validateBankDetails(merchantBankAccountRequest);
        logger.debug("Merchant bank account details validation completed for {}", merchantBankAccountRequest);
    }

    /**
     * Validate merchant account approval request
     * @param merchantBankAccountApprovalRequest MerchantBankAccountApprovalRequest
     */
    public void validateMerchantAccountApprovalRequest(MerchantBankAccountApprovalRequest merchantBankAccountApprovalRequest) {
        logger.debug("Merchant bank account approval validation start for {}", merchantBankAccountApprovalRequest);
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(merchantBankAccountApprovalRequest);
        validateMId(merchantBankAccountApprovalRequest.getMId());
        validateAccountUniqueIdentifier(merchantBankAccountApprovalRequest.getAccountUniqueIdentifier());
    }

    public void validateMId(String mId) {
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        List<MerchantInfoDto> merchantInfoForMerchantUser = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);
        List<String> validMIds = merchantInfoForMerchantUser.stream().filter(m -> MerchantStatus.ACTIVE.name().equalsIgnoreCase(m.getStatus())).map(MerchantInfoDto::getMId).toList();
        if (validMIds.contains(mId)) {
            return;
        }
        throw new ValidationException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, MID, MID_ACCESS));
    }

    private void validateFieldValue(MerchantBankAccountRequest merchantBankAccountRequest) {
        validateFieldValue(merchantBankAccountRequest.getAccountType(), List.of(AccountType.SAVING.name(), AccountType.CURRENT.name()), ACCOUNT_TYPE);
        throwIfErrors();
        try {
            EncryptionDecryptionUtil.decryptValue(merchantConfig.getDecryptionKey(), merchantBankAccountRequest.getAccountNumber());
        } catch (Exception e) {
            throw new ValidationException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, ACCOUNT_NUMBER, DECRYPTION_FAILED));
        }
    }

    private void validatedMandatoryFields(MerchantBankAccountRequest merchantBankAccountRequest) {
        checkMandatoryField(merchantBankAccountRequest.getBankName(), BANK_NAME);
        checkMandatoryField(merchantBankAccountRequest.getBranchName(), BRANCH_NAME);
        checkMandatoryField(merchantBankAccountRequest.getIfscCode(), IFSC_CODE);
        checkMandatoryField(merchantBankAccountRequest.getAccountType(), ACCOUNT_TYPE);
        checkMandatoryField(merchantBankAccountRequest.getAccountNumber(), ACCOUNT_NUMBER);
        checkMandatoryField(merchantBankAccountRequest.getAccountHolderName(), ACCOUNT_HOLDER_NAME);
        checkMandatoryField(merchantBankAccountRequest.getAccountUniqueIdentifier(), ACCOUNT_UNIQUE_IDENTIFIER);
        checkMandatoryField(merchantBankAccountRequest.getMId(), MID);
        throwIfErrors();
    }

    private void validateMandatoryFields(MerchantBankAccountApprovalRequest merchantBankAccountApprovalRequest) {
        checkMandatoryField(merchantBankAccountApprovalRequest.getAccountName(), ACCOUNT_HOLDER_NAME);
        checkMandatoryField(merchantBankAccountApprovalRequest.getMId(), MID);
        checkMandatoryField(merchantBankAccountApprovalRequest.getAccountUniqueIdentifier(), ACCOUNT_UNIQUE_IDENTIFIER);
        if(!merchantBankAccountApprovalRequest.isApproved()) {
            checkMandatoryField(merchantBankAccountApprovalRequest.getRemarks(), REMARK);
        }
    }

    private void validateBankDetails(MerchantBankAccountRequest merchantBankAccountRequest) {
        MerchantResponse<String> response = adminServicesClient.validateBankDetails(merchantBankAccountRequest.getBankName(), merchantBankAccountRequest.getBranchName(), merchantBankAccountRequest.getIfscCode());
        if (response.getStatus() == RESPONSE_FAILURE) {
            throw new ValidationException(response.getErrors());
        }
    }

    private void validateAccountUniqueIdentifier(MerchantBankAccountRequest merchantBankAccountRequest) {
        boolean existByAccountUniqueIdentifier = merchantBankDao.isExistByAccountUniqueIdentifier(merchantBankAccountRequest.getAccountUniqueIdentifier());
        if (existByAccountUniqueIdentifier) {
            errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, "AccountUniqueIdentifier")).build());
        }
        boolean existByAccountNumber = merchantBankDao.isExistByAccountNumber(merchantBankAccountRequest.getAccountNumber());
        if (existByAccountNumber) {
            errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, ACCOUNT_NUMBER)).build());
        }
        throwIfErrors();
    }

    private void validateAccountUniqueIdentifier(String uniqueIdentifier) {
        boolean existByAccountUniqueIdentifier = merchantBankDao.isExistByAccountUniqueIdentifier(uniqueIdentifier);
        if(!existByAccountUniqueIdentifier) {
            errorDtoList.add(ErrorDto.builder().errorCode(NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, ACCOUNT_UNIQUE_IDENTIFIER)).build());
        }
        throwIfErrors();
    }

    private void validateAccountUniqueIdentifierForUpdate(MerchantBankAccountRequest merchantBankAccountRequest) {
        MerchantBankAccountDto dbMerchantBankAccount = merchantBankDao.getAccountByAccountUniqueIdentifier(merchantBankAccountRequest.getAccountUniqueIdentifier());
        if (!merchantBankAccountRequest.getAccountNumber().equalsIgnoreCase(dbMerchantBankAccount.getAccountNumber())) {
            boolean existByAccountNumber = merchantBankDao.isExistByAccountNumber(merchantBankAccountRequest.getAccountNumber());
            if (existByAccountNumber) {
                errorDtoList.add(ErrorDto.builder().errorCode(ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(ALREADY_EXIST_ERROR_MESSAGE, ACCOUNT_NUMBER)).build());
            }
            throwIfErrors();
        }
    }

}
