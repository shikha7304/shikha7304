package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.constant.EPayAuthenticationConstant;
import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.security.Key;
import java.text.MessageFormat;
import java.util.Base64;
import java.util.Date;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class JwtServiceTest {

    @InjectMocks
    private JwtService jwtService;

    @Mock
    private AuthenticationUserService authenticationUserService;

    private String secretKey;
    private String issuer;

    @BeforeEach
    void setUp() throws Exception {
        // Generate a valid secret key
        secretKey = Base64.getEncoder().encodeToString(Keys.secretKeyFor(SignatureAlgorithm.HS512).getEncoded());
        issuer = "testIssuer";

        // Set private fields using reflection
        java.lang.reflect.Field secretKeyField = JwtService.class.getDeclaredField("secretKey");
        secretKeyField.setAccessible(true);
        secretKeyField.set(jwtService, secretKey);

        java.lang.reflect.Field issuerField = JwtService.class.getDeclaredField("issuer");
        issuerField.setAccessible(true);
        issuerField.set(jwtService, issuer);
    }

    @Test
    void testVerifyJwtTokenAndGetClaims_ValidToken() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        EPayPrincipal ePayPrincipal = mock(EPayPrincipal.class);
        when(ePayPrincipal.getAuthenticationId()).thenReturn("testUser");

        when(authenticationUserService.isTokenInValid(token, "ACCESS")).thenReturn(false);
        when(authenticationUserService.loadUserByUserName(anyString())).thenReturn(Optional.of(ePayPrincipal));

        Claims resultClaims = jwtService.verifyJwtTokenAndGetClaims(token);

        assertNotNull(resultClaims);
        assertEquals("testUser", resultClaims.get("username"));
    }

    @Test
    void testVerifyJwtTokenAndGetClaims_TokenExpired() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() - 1000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(token));

        assertEquals(EPayAuthenticationErrorConstants.TOKEN_EXPIRED, exception.getMessage());
    }

    @Test
    void testVerifyJwtTokenAndGetClaims_InvalidToken() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        when(authenticationUserService.isTokenInValid(token, "ACCESS")).thenReturn(true);

        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(token));

        assertEquals(EPayAuthenticationErrorConstants.INVALID_TOKEN, exception.getMessage());
    }

    @Test
    void testVerifyJwtTokenAndGetClaims_InvalidIssuer() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer("wrongIssuer");
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(token));

        assertEquals(EPayAuthenticationErrorConstants.INVALID_ISSUER, exception.getMessage());
    }

    @Test
    void testVerifyJwtTokenAndGetClaims_InvalidUser() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        EPayPrincipal ePayPrincipal = mock(EPayPrincipal.class);
        when(ePayPrincipal.getAuthenticationId()).thenReturn("wrongUser");

        when(authenticationUserService.isTokenInValid(token, "ACCESS")).thenReturn(false);
        when(authenticationUserService.loadUserByUserName(anyString())).thenReturn(Optional.of(ePayPrincipal));

        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(token));

        assertEquals(EPayAuthenticationErrorConstants.INVALID_USER, exception.getMessage());
    }

    @Test
    void testGetAllClaimsFromToken_ValidToken() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        Claims resultClaims = jwtService.verifyJwtTokenAndGetClaims(token);

        assertNotNull(resultClaims);
        assertEquals("testUser", resultClaims.get("username"));
    }

    @Test
    void testGetAllClaimsFromToken_ExpiredToken() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() - 1000));

        String token = Jwts.builder()
                .setClaims(claims)
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512)
                .compact();

        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(token));

        assertEquals(EPayAuthenticationErrorConstants.TOKEN_EXPIRED, exception.getMessage());
    }

    @Test
    void testGetSignKey() {
        Key key = jwtService.getSignKey();
        assertNotNull(key);
    }

    @Test
    void testIsTokenExpired_True() {
        assertTrue(jwtService.isTokenExpired(new Date(System.currentTimeMillis() - 10000)));
    }

    @Test
    void testIsTokenExpired_False() {
        assertFalse(jwtService.isTokenExpired(new Date(System.currentTimeMillis() + 10000)));
    }
}








public Claims verifyJwtTokenAndGetClaims(String token) {
        Claims claims = getAllClaimsFromToken(token);
        if (issuer.equalsIgnoreCase(claims.getIssuer())) {
            if (isTokenExpired(claims.getExpiration())) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.TOKEN_EXPIRED);
            } else if (authenticationUserService.isTokenInValid(token, claims.get(TYPE, String.class))) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_TOKEN);
            }
            String userName = (String) claims.get(USERNAME);
            String userNameWithTokenType = String.join(EPayAuthenticationConstant.JOINER, (String) claims.get(USERNAME), claims.get(TYPE, String.class));
            logger.info("Token request received for userNameWithTokenType: {}", userNameWithTokenType);
            EPayPrincipal ePayPrincipal = authenticationUserService.loadUserByUserName(userNameWithTokenType).orElseThrow(() -> new EPaySecurityException(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_MESSAGE, EPayAuthenticationErrorConstants.USER_NAME)));
            logger.info("Token request received for userNameWithTokenType: {}", userNameWithTokenType);
            if (!ePayPrincipal.getAuthenticationId().equalsIgnoreCase(userName)) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_USER);
            }
        } else {
            throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_ISSUER);
        }
        return claims;
    }


    /**
     * Get all claims from token. and @Param token
     *
     * @param token as a String
     * @return Claims of the token
     */
    private Claims getAllClaimsFromToken(String token) {
        try {
            logger.info("ClassName - JwtService,MethodName - getAllClaimsFromToken, getting all claims from token.");
            return Jwts.parserBuilder().setSigningKey(getSignKey()).build().parseClaimsJws(token).getBody();
        } catch (ExpiredJwtException e) {
            logger.error("Jwt Token is expired : {}", e.getLocalizedMessage());
            throw new IllegalStateException(EPayAuthenticationErrorConstants.TOKEN_EXPIRED);
        }  catch (SignatureException e) {
            logger.error("Jwt Token is expired : {}", e.getLocalizedMessage());
            throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_TOKEN);
       }

    }

    /**
     * Get SigningKey
     *
     * @return signed key
     */
    protected Key getSignKey() {
        logger.info("ClassName - JwtService,MethodName - getSignKey, getting SigningKey.");
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * Get expiration time from token
     *
     * @param expiration is as Date
     * @return Boolean true if token is expired otherwise false.
     */
    private Boolean isTokenExpired(Date expiration) {
        logger.info("ClassName - JwtService,MethodName - isTokenExpired, getting expiration time from token.");
        return expiration.before(new Date());
    }
