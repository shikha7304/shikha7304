import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Optional;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SecurityServiceTest {

    @Mock
    private MerchantServiceClient merchantServiceClient;

    @InjectMocks
    private SecurityService securityService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testLoadUserByUserName_Success() {
        // Given
        String userName = "testUser";
        String tokenType = "USER";
        String userNameWithTokenType = userName + "_" + tokenType;
        ReportingResponse<String> mockResponse = new ReportingResponse<>();
        mockResponse.setStatus(ReportingConstant.RESPONSE_SUCCESS);
        mockResponse.setErrors(null);

        when(merchantServiceClient.validateMerchantUser(userName)).thenReturn(mockResponse);

        // When
        Optional<EPayPrincipal> result = securityService.loadUserByUserName(userNameWithTokenType);

        // Then
        assertTrue(result.isPresent(), "Expected an EPayPrincipal object");
        assertEquals(userName, result.get().getAuthenticationId(), "Authentication ID should match");
        verify(merchantServiceClient, times(1)).validateMerchantUser(userName);
    }

    @Test
    void testLoadUserByUserName_InvalidTokenType() {
        // Given
        String userNameWithTokenType = "testUser_INVALID";

        // When
        Optional<EPayPrincipal> result = securityService.loadUserByUserName(userNameWithTokenType);

        // Then
        assertTrue(result.isEmpty(), "Expected an empty result for invalid token type");
        verifyNoInteractions(merchantServiceClient);
    }

    @Test
    void testLoadUserByUserName_MerchantValidationFails() {
        // Given
        String userName = "testUser";
        String tokenType = "USER";
        String userNameWithTokenType = userName + "_" + tokenType;
        ReportingResponse<String> mockResponse = new ReportingResponse<>();
        mockResponse.setStatus(ReportingConstant.RESPONSE_FAILURE);

        when(merchantServiceClient.validateMerchantUser(userName)).thenReturn(mockResponse);

        // When
        Optional<EPayPrincipal> result = securityService.loadUserByUserName(userNameWithTokenType);

        // Then
        assertTrue(result.isEmpty(), "Expected an empty result when merchant validation fails");
        verify(merchantServiceClient, times(1)).validateMerchantUser(userName);
    }

    @Test
    void testLoadUserByUserName_InvalidInputFormat() {
        // Given
        String userNameWithTokenType = "invalidFormat"; // No separator

        // When
        Optional<EPayPrincipal> result = securityService.loadUserByUserName(userNameWithTokenType);

        // Then
        assertTrue(result.isEmpty(), "Expected an empty result for invalid input format");
        verifyNoInteractions(merchantServiceClient);
    }

    @Test
    void testIsTokenInValid_Success() {
        // Given
        String token = "validToken";
        String tokenType = "USER";
        ReportingResponse<String> mockResponse = new ReportingResponse<>();
        mockResponse.setStatus(ReportingConstant.RESPONSE_SUCCESS);
        mockResponse.setErrors(null);

        when(merchantServiceClient.validateMerchantToken(token)).thenReturn(mockResponse);

        // When
        boolean result = securityService.isTokenInValid(token, tokenType);

        // Then
        assertFalse(result, "Expected token to be valid");
        verify(merchantServiceClient, times(1)).validateMerchantToken(token);
    }

    @Test
    void testIsTokenInValid_InvalidTokenType() {
        // Given
        String token = "someToken";
        String invalidTokenType = "INVALID";

        // When
        boolean result = securityService.isTokenInValid(token, invalidTokenType);

        // Then
        assertTrue(result, "Expected token to be invalid due to invalid token type");
        verifyNoInteractions(merchantServiceClient);
    }

    @Test
    void testIsTokenInValid_MerchantValidationFails() {
        // Given
        String token = "invalidToken";
        String tokenType = "USER";
        ReportingResponse<String> mockResponse = new ReportingResponse<>();
        mockResponse.setStatus(ReportingConstant.RESPONSE_FAILURE);

        when(merchantServiceClient.validateMerchantToken(token)).thenReturn(mockResponse);

        // When
        boolean result = securityService.isTokenInValid(token, tokenType);

        // Then
        assertTrue(result, "Expected token to be invalid when merchant validation fails");
        verify(merchantServiceClient, times(1)).validateMerchantToken(token);
    }
}





package com.epay.reporting.service;

import com.epay.reporting.externalservice.MerchantServiceClient;
import com.epay.reporting.model.response.ReportingResponse;
import com.epay.reporting.util.ReportingConstant;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.service.AuthenticationUserService;
import com.sbi.epay.authentication.util.EPayAuthenticationConstant;
import com.sbi.epay.authentication.util.enums.TokenType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import java.util.Optional;

/**
 * Class Name: SecurityService
 * *
 * Description: This service class handles user authentication and token validation
 * for the merchant system. It interacts with the `MerchantServiceClient` to validate
 * merchant users and tokens. It implements the `AuthenticationUserService` interface
 * to load users based on their credentials and check the validity of their tokens.
 * It also provides logging functionality to track the flow of the authentication process.
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class SecurityService implements AuthenticationUserService {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantServiceClient merchantServiceClient;

    /**
     * Method Name: loadUserByUserName
     * <p>
     * Description: This method extracts the username and token type from the provided
     * `userNameWithTokenType` string, validates the merchant user using the `merchantServiceClient`,
     * and returns an `EPayPrincipal` object if the validation is successful. It logs the
     * process for debugging and traceability. If validation fails, an empty `Optional` is returned.
     *
     * @param userNameWithTokenType String - A string that contains the username and token type,
     *                              separated by a predefined delimiter.
     * @return Optional<EPayPrincipal> - An `Optional` containing the `EPayPrincipal` if the user is valid,
     * or an empty `Optional` if the user is invalid.
     */
    @Override
    public Optional<EPayPrincipal> loadUserByUserName(String userNameWithTokenType) {
        log.info("Attempting to load user by username and token type: {}", userNameWithTokenType);

        String[] users = userNameWithTokenType.split(EPayAuthenticationConstant.JOINER);
        if (users.length > 0 && StringUtils.isNotEmpty(users[1]) && TokenType.USER.equals(TokenType.valueOf(users[1]))) {
            log.info("Token type is USER. Validating merchant user: {}", users[0]);
            ReportingResponse<String> response = merchantServiceClient.validateMerchantUser(users[0]);
            if (response.getStatus() == ReportingConstant.RESPONSE_SUCCESS && CollectionUtils.isEmpty(response.getErrors())) {
                log.info("Merchant user validation successful for: {}", users[0]);
                EPayPrincipal authenticateEntity = new EPayPrincipal();
                authenticateEntity.setAuthenticationId(users[0]);
                return Optional.of(authenticateEntity);
            }
        }
        return Optional.empty();
    }


    /**
     * Method Name: isTokenInValid
     * <p>
     * Description: This method checks if the provided token is valid based on the token type.
     * It validates the token type, and if it is a USER token, it calls the `merchantServiceClient`
     * to validate the token. If the token is invalid, it returns true; otherwise, it returns false.
     * It logs the process for better traceability and debugging.
     *
     * @param token     String - The token to be validated.
     * @param tokenType String - The type of the token (e.g., USER).
     * @return boolean - Returns `true` if the token is invalid, `false` if the token is valid.
     */
    @Override
    public boolean isTokenInValid(String token, String tokenType) {
        log.info("Checking token validity for token: {} and tokenType: {}", token, tokenType);
        if (StringUtils.isNotEmpty(tokenType) && TokenType.USER.equals(TokenType.valueOf(tokenType))) {
            log.info("Token type is USER. Validating merchant token: {}", token);
            ReportingResponse<String> response = merchantServiceClient.validateMerchantToken(token);
            return !ObjectUtils.isNotEmpty(response) || response.getStatus() != ReportingConstant.RESPONSE_SUCCESS || !CollectionUtils.isEmpty(response.getErrors());
        }
        log.warn("Invalid token type: {}", tokenType);
        return true;
    }
}

package com.epay.reporting.externalservice;


import com.epay.reporting.client.ApiClient;
import com.epay.reporting.exception.ReportingException;
import com.epay.reporting.externalservice.request.UserValidationRequest;
import com.epay.reporting.model.response.ReportingResponse;
import com.epay.reporting.util.EPayIdentityUtil;
import com.epay.reporting.util.ErrorConstants;
import com.sbi.epay.authentication.providers.EPayTokenProvider;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import reactor.core.publisher.Mono;

import java.net.URI;

/**
 * Class Name: MerchantServiceClient
 * *
 * Description:  This class provides methods for interacting with the Merchant Service API,
 * specifically for validating merchant-related data, such as user, token, and merchant ID (MID) access.
 * It extends the ApiClient class, utilizing WebClient for making HTTP requests.
 * This service supports different types of validations including login, token validation,
 * and access rights for active and non-active merchant IDs.
 * Author: V1018482
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
public class MerchantServiceClient extends ApiClient {

    public static final String MID_VALIDATION = "/validation/access/";
    public static final String ACTIVE_MID_VALIDATION = "/validation/access/active/";
    public static final String USER_VALIDATION = "/validation/user";
    public static final String TOKEN_VALIDATION = "/validation/token";
    public static final String BEARER = "Bearer ";

    private final EPayTokenProvider ePayTokenProvider;

    /**
     * Constructor for initializing the MerchantServiceClient with a base URL and EPayTokenProvider.
     *
     * @param baseUrl the base URL of the Merchant Service API
     * @param ePayTokenProvider the provider for fetching ePay tokens
     */
    public MerchantServiceClient(String baseUrl, EPayTokenProvider ePayTokenProvider) {
        super(baseUrl);
        this.ePayTokenProvider = ePayTokenProvider;
    }

    /**
     * Validates the user by making a POST request to the user validation endpoint.
     *
     * @param userName the username to validate
     * @return a ReportingResponse containing validation status as a String
     */
    public ReportingResponse<String> validateMerchantUser(String userName) {
        URI uri = URI.create(getBaseUrl() + USER_VALIDATION);
        return getWebClient().post().uri(uri).bodyValue(UserValidationRequest.builder().requestType("LOGIN").userName(userName).build()).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new ReportingException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE))).bodyToMono(new ParameterizedTypeReference<ReportingResponse<String>>() {
        }).block();
    }

    /**
     * Validates the provided token by making a GET request to the token validation endpoint.
     *
     * @param token the token to validate
     * @return a ReportingResponse containing validation status as a String
     */
    public ReportingResponse<String> validateMerchantToken(String token) {
        HttpHeaders headers = prepareHttpHeaders();
        headers.set(HttpHeaders.AUTHORIZATION, BEARER + token);
        URI uri = URI.create(getBaseUrl() + TOKEN_VALIDATION);
        return getWebClient().get().uri(uri).headers(httpHeaders -> httpHeaders.addAll(headers)).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new ReportingException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE))).bodyToMono(new ParameterizedTypeReference<ReportingResponse<String>>() {
        }).block();
    }

    /**
     * Validates access to a merchant ID (MID) for the current user.
     *
     * @param mId the merchant ID to validate
     * @return a ReportingResponse containing validation status as a String
     */
    public ReportingResponse<String> validateMIdAccess(String mId) {
        HttpHeaders headers = prepareHttpHeaders();
        headers.set(HttpHeaders.AUTHORIZATION, BEARER + ePayTokenProvider.getToken());
        URI uri = URI.create(getBaseUrl() + MID_VALIDATION + EPayIdentityUtil.getUserPrincipal().getUsername() + "/" + mId);
        return getWebClient().get().uri(uri).headers(httpHeaders -> httpHeaders.addAll(headers)).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new ReportingException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE))).bodyToMono(new ParameterizedTypeReference<ReportingResponse<String>>() {
        }).block();
    }

    /**
     * Validates access to an active merchant ID (MID) for the current user.
     *
     * @param mId the merchant ID to validate
     * @return a ReportingResponse containing validation status as a String
     */
    public ReportingResponse<String> validateActiveMIdAccess(String mId) {
        HttpHeaders headers = prepareHttpHeaders();
        headers.set(HttpHeaders.AUTHORIZATION, BEARER + ePayTokenProvider.getToken());
        URI uri = URI.create(getBaseUrl() + ACTIVE_MID_VALIDATION + EPayIdentityUtil.getUserPrincipal().getUsername() + "/" + mId);
        return getWebClient().get().uri(uri).headers(httpHeaders -> httpHeaders.addAll(headers)).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new ReportingException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE))).bodyToMono(new ParameterizedTypeReference<ReportingResponse<String>>() {
        }).block();
    }

}
