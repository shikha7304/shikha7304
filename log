package com.epay.merchant.service;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.PasswordManagementDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.request.PasswordChangeRequest;
import com.epay.merchant.model.request.PasswordResetRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.RequestType;
import com.epay.merchant.util.enums.UserStatus;
import com.epay.merchant.validator.PasswordValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

import static com.epay.merchant.util.EncryptionDecryptionUtil.decryptValue;
import static com.epay.merchant.util.EncryptionDecryptionUtil.hashValue;

/**
 * Class Name: PasswordService
 * *
 * Description:
 * *
 * Author: Subhra Goswami
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class PasswordService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final PasswordValidator passwordValidator;
    private final PasswordManagementDao passwordManagementDao;
    private final MerchantConfig merchantConfig;

    /**
     * Method to handle the password change logic
     * @param passwordChangeRequest PasswordChangeRequest
     */
    public MerchantResponse<String> changePassword(PasswordChangeRequest passwordChangeRequest) {
        try {
            log.info("Starting password change process for user: {}", passwordChangeRequest.getUserName());
            // Step 1: Validate mandatory password reset request
            passwordValidator.validateMandatoryFields(passwordChangeRequest);
            log.info("Password change request validated successfully for mandatory field");

            // Step 2 : Decrypt Password
            passwordChangeRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getNewPassword()));
            passwordChangeRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getConfirmPassword()));
            log.info("Password change request decrypted successfully");

            // Step 3: Validate the password change request
            validatePasswordChange(passwordChangeRequest);
            log.info("Password change request validated successfully");

            // Step 4: Update the password details in the database
            passwordManagementDao.updatePasswordDetails(passwordChangeRequest.getUserName(), passwordChangeRequest.getNewPassword(), List.of(UserStatus.EXPIRED), RequestType.CHANGE_PASSWORD);

            // Step 5: Build and return the success response
            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Changed Successfully")).count(1L).total(1L).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> ErrorConstants.MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("Password Change Request Validation Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw e;
        } catch (MerchantException e) {
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessage());
            log.error("Password Change Request Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw e;
        } catch (Exception e) {
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getLocalizedMessage());
            log.error("Password Change Request Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Method to handle the reset password logic
     * @param passwordResetRequest PasswordResetRequest
     */
    public MerchantResponse<String> resetPassword(PasswordResetRequest passwordResetRequest) {
        try {
            log.info("Starting password reset process for user: {}", passwordResetRequest.getUserName());
            // Step 1: Validate mandatory password reset request
            passwordValidator.validateMandatoryFields(passwordResetRequest);
            log.info("Password reset request validated successfully for mandatory field");

            // Step 2 : Decrypt Password
            passwordResetRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getNewPassword()));
            passwordResetRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getConfirmPassword()));
            log.info("Password reset request decrypted successfully");

            // Step 3: Validate the password reset request
            validatePasswordReset(passwordResetRequest);
            log.info("Password reset request validated successfully");

            // Step 4: Update the password details in the database
            passwordManagementDao.updatePasswordDetails(passwordResetRequest.getUserName(), passwordResetRequest.getNewPassword(), List.of(UserStatus.ACTIVE), RequestType.RESET_PASSWORD);

            // Step 5: Build and return the success response
            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Reset Successfully")).count(1L).total(1L).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> ErrorConstants.MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("Password Reset Request Validation Failed for passwordResetRequest {} ", passwordResetRequest);
            throw e;
        } catch (MerchantException e) {
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getErrorMessage());
            log.error("Password Reset Request Failed for passwordResetRequest {} ", passwordResetRequest);
            throw e;
        } catch (Exception e) {
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getLocalizedMessage());
            log.error("Password Reset Request Failed for passwordResetRequest {} ", passwordResetRequest);
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Method to validate the user status and create hash password and update in DB
     * @param passwordChangeRequest PasswordChangeRequest
     */
    private void validatePasswordChange(PasswordChangeRequest passwordChangeRequest) {
        log.info("Validating password change request for user: {}", passwordChangeRequest.getUserName());
        passwordValidator.validatePasswordValue(passwordChangeRequest.getNewPassword(), passwordChangeRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordChangeRequest.getUserName(), List.of(UserStatus.EXPIRED));
        String passwordHashValue = hashValue(passwordChangeRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue, passwordChangeRequest.getOldPassword());
    }

    /**
     * Method to validate the reset password logic
     * @param passwordResetRequest PasswordResetRequest
     */
    private void validatePasswordReset(PasswordResetRequest passwordResetRequest) {
        passwordValidator.validatePasswordValue(passwordResetRequest.getNewPassword(), passwordResetRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordResetRequest.getUserName(), List.of(UserStatus.ACTIVE));
        String passwordHashValue = hashValue(passwordResetRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue);
    }

    /**
     * Method to handle password failure logic
     * @param userName String
     * @param requestType RequestType
     * @param e String
     */
    private void handlePasswordFailure(String userName, RequestType requestType, String e) {
        if (StringUtils.isNotEmpty(userName)) {
            try {
                passwordManagementDao.saveAudit(userName, requestType, false, e);
            } catch (MerchantException ex) {
                log.error("Error in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getErrorMessages());
            } catch (Exception ex) {
                log.error("Error in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getMessage());
            }
        }
    }
}


public class SecurityService implements AuthenticationUserService {

    private final TokenDao tokenDao;
    private final MerchantUserDao merchantUserDao;


    /**
     This method will call the authenticateEntity to authenticate and get the userName by token
     @param userName String
     */
    @Override
    public Optional<EPayPrincipal> loadUserByUserName(String userName) {
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        EPayPrincipal authenticateEntity = new EPayPrincipal();
        authenticateEntity.setAuthenticationId(merchantUserDto.getUserName());
        return Optional.of(authenticateEntity);
    }
    /**
     * It will check if the token is valid or not
     */
    @Override
    public boolean isTokenInValid(String token) {
        return !tokenDao.isValidTokenExist(token);
    }
}
