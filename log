import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;

class HashingServiceTest {

    @Test
    void testGenerateHashWithInvalidAlgorithmThrowsException() throws Exception {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Use Reflection to create a fake HashAlgorithm instance with an invalid algorithm name
        HashAlgorithm invalidAlgorithm = createInvalidHashAlgorithm("INVALID_ALGORITHM");

        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> HashingService.generateHash(inputData, invalidAlgorithm)
        );

        assertEquals(EncryptionDecryptionConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }

    @Test
    void testGenerateHashWithGenericException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Force a generic exception by passing null as input data
        assertThrows(NullPointerException.class, () ->
            HashingService.generateHash(null, HashAlgorithm.SHA_256)
        );
    }

    // Helper method to create an invalid HashAlgorithm instance using reflection
    private HashAlgorithm createInvalidHashAlgorithm(String algorithmName) throws Exception {
        Constructor<HashAlgorithm> constructor = HashAlgorithm.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        HashAlgorithm fakeAlgorithm = constructor.newInstance();

        // Set the algorithm name field to an invalid value
        Field field = HashAlgorithm.class.getDeclaredField("algorithmName");
        field.setAccessible(true);
        field.set(fakeAlgorithm, algorithmName);

        return fakeAlgorithm;
    }
}





import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;

class HashingServiceTest {

    @Test
    void testGenerateHashWithInvalidAlgorithmThrowsException() throws Exception {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);
        
        // Use Reflection to pass an invalid algorithm
        Method method = HashAlgorithm.class.getDeclaredMethod("valueOf", String.class);
        method.setAccessible(true);
        HashAlgorithm invalidAlgorithm = (HashAlgorithm) method.invoke(null, "INVALID_ALGORITHM");

        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> HashingService.generateHash(inputData, invalidAlgorithm)
        );

        assertEquals(EncryptionDecryptionConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }

    @Test
    void testGenerateHashWithGenericException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Force a generic exception by passing null to an array
        assertThrows(EncryptionDecryptionException.class, () ->
            HashingService.generateHash(null, HashAlgorithm.SHA_256)
        );
    }
}





import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.mockito.Mockito;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

class HashingServiceTest {

    @Test
    void testGenerateHashWithInvalidAlgorithmThrowsException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Mock HashAlgorithm to return an invalid algorithm name
        HashAlgorithm invalidAlgorithm = Mockito.mock(HashAlgorithm.class);
        Mockito.when(invalidAlgorithm.getAlgorithmName()).thenReturn("INVALID_ALGORITHM");

        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> HashingService.generateHash(inputData, invalidAlgorithm)
        );

        assertEquals(EncryptionDecryptionConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }

    @Test
    void testGenerateHashWithGenericException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Mock HashAlgorithm to throw a RuntimeException
        HashAlgorithm algorithm = Mockito.mock(HashAlgorithm.class);
        Mockito.when(algorithm.getAlgorithmName()).thenThrow(new RuntimeException("Unexpected error"));

        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> HashingService.generateHash(inputData, algorithm)
        );

        assertEquals(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, exception.getErrorCode());
    }
}



    public static byte[] generateHash(byte @NonNull [] data, @NonNull HashAlgorithm algorithm) throws EncryptionDecryptionException {
        try {
            log.debug("HashingService :: generateHash  data {}, algorithm {}", data, algorithm);
            MessageDigest digest = MessageDigest.getInstance(algorithm.getAlgorithmName());
            return digest.digest(data);
        } catch (NoSuchAlgorithmException e) {
            log.error("HashingService :: generateHash {}", e);
            throw new EncryptionDecryptionException(EncryptionDecryptionConstants.INVALID_ERROR_CODE, MessageFormat.format(EncryptionDecryptionConstants.INVALID_ERROR_MESSAGE, "hash algorithm"));
        } catch (Exception e) {
            log.error("HashingService :: generateHash {}", e);
            throw new EncryptionDecryptionException(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, EncryptionDecryptionConstants.GENERIC_ERROR_MESSAGE);
        }
    }



############
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

class HashingServiceTest {

    @Test
    void testGenerateHashSuccess() throws EncryptionDecryptionException {
        String input = "TestData";
        byte[] inputData = input.getBytes(StandardCharsets.UTF_8);
        HashAlgorithm algorithm = HashAlgorithm.SHA_256;
        byte[] hashedData = HashingService.generateHash(inputData, algorithm);
        assertNotNull(hashedData);
        assertTrue(hashedData.length > 0);
    }

    @Test
    void testGenerateHashWithNullDataThrowsException() {
        HashAlgorithm algorithm = HashAlgorithm.SHA_256;
        assertThrows(NullPointerException.class, () -> HashingService.generateHash(null, algorithm));
    }

    @Test
    void testGenerateHashWithNullAlgorithmThrowsException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);
        assertThrows(NullPointerException.class, () -> HashingService.generateHash(inputData, null));
    }

    @Test
    void testGenerateHashWithInvalidAlgorithmThrowsException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Directly trigger NoSuchAlgorithmException by calling an invalid algorithm manually
        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> generateHashWithInvalidAlgorithm(inputData)
        );

        assertEquals(EncryptionDecryptionConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }

    @Test
    void testGenerateHashWithGenericException() {
        byte[] inputData = "TestData".getBytes(StandardCharsets.UTF_8);

        // Manually trigger a generic exception scenario
        EncryptionDecryptionException exception = assertThrows(
            EncryptionDecryptionException.class,
            () -> generateHashWithUnexpectedException(inputData)
        );

        assertEquals(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, exception.getErrorCode());
    }

    /**
     * Helper method to simulate NoSuchAlgorithmException
     */
    private byte[] generateHashWithInvalidAlgorithm(byte[] data) throws EncryptionDecryptionException {
        try {
            MessageDigest digest = MessageDigest.getInstance("INVALID_ALGORITHM"); // Invalid name
            return digest.digest(data);
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionDecryptionException(
                EncryptionDecryptionConstants.INVALID_ERROR_CODE,
                EncryptionDecryptionConstants.INVALID_ERROR_MESSAGE
            );
        }
    }

    /**
     * Helper method to simulate a generic exception
     */
    private byte[] generateHashWithUnexpectedException(byte[] data) throws EncryptionDecryptionException {
        try {
            throw new RuntimeException("Unexpected error"); // Force a runtime exception
        } catch (Exception e) {
            throw new EncryptionDecryptionException(
                EncryptionDecryptionConstants.GENERIC_ERROR_CODE,
                EncryptionDecryptionConstants.GENERIC_ERROR_MESSAGE
            );
        }
    }
}
