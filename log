public void info(String format, Object... arguments) {
    setMDC(); // Maintain MDC context

    // Mask sensitive data before logging
    Object[] sanitizedArguments = maskSensitiveData(arguments);
    
    logger.info(format, sanitizedArguments);
}

/**
 * Masks sensitive data before logging.
 */
private Object[] maskSensitiveData(Object... arguments) {
    if (arguments == null) {
        return null;
    }

    Object[] sanitizedArgs = new Object[arguments.length];
    for (int i = 0; i < arguments.length; i++) {
        if (arguments[i] instanceof String && containsSensitiveData((String) arguments[i])) {
            sanitizedArgs[i] = "****";  // Mask data
        } else {
            sanitizedArgs[i] = arguments[i];
        }
    }
    return sanitizedArgs;
}

/**
 * Checks if data is sensitive.
 */
private boolean containsSensitiveData(String data) {
    return data.toLowerCase().contains("key") || data.toLowerCase().contains("password") || data.toLowerCase().contains("secret");
}







public static String decryptValueBySecretKey(@NonNull SecretKey key, @NonNull String value, @NonNull EncryptionDecryptionAlgo algorithm, @NonNull GCMIvLength gcmIvLength, @NonNull GCMTagLength gcmTagLength) throws EncryptionDecryptionException {
        log.info("Decryption Service :: algorithm : {}, gcmIvLength : {}, gcmTagLength : {}", algorithm, gcmIvLength, gcmTagLength);
        try {
            return decrypt(key, value, algorithm, gcmIvLength, gcmTagLength);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 InvalidAlgorithmParameterException | IllegalArgumentException | UnsupportedOperationException |
                 IllegalStateException | IllegalBlockSizeException | BadPaddingException e) {
            log.error("DecryptionService :: decrypt {}", e.getMessage());
            throw new EncryptionDecryptionException(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, EncryptionDecryptionConstants.GENERIC_ERROR_MESSAGE);
        }
    }




public void info(String format, Object... arguments) {
    setMDC(); // Maintain MDC context
    
    // Check if arguments contain sensitive data
    Object[] sanitizedArguments = sanitizeSensitiveData(arguments);
    
    logger.info(format, sanitizedArguments);
}

/**
 * Helper method to mask sensitive data
 */
private Object[] sanitizeSensitiveData(Object... arguments) {
    if (arguments == null) {
        return null;
    }

    Object[] sanitizedArgs = new Object[arguments.length];

    for (int i = 0; i < arguments.length; i++) {
        if (isSensitiveData(arguments[i])) {
            sanitizedArgs[i] = "****";  // Mask sensitive data
        } else {
            sanitizedArgs[i] = arguments[i];
        }
    }

    return sanitizedArgs;
}

/**
 * Define sensitive data types that need masking
 */
private boolean isSensitiveData(Object data) {
    if (data == null) return false;
    
    String str = data.toString().toLowerCase();
    return str.contains("key") || str.contains("password") || str.contains("secret");
}





Yes! If you want to fix the Privacy Violation issue with minimal code changes, here’s a simpler approach:

1. Fix in DecryptionService.java (Minimal Change)

Modify the logging statement to remove sensitive data (like key and value):

log.info("Decryption Service :: algorithm: {}, gcmIvLength: {}, gcmTagLength: {}", 
        algorithm, gcmIvLength, gcmTagLength);

✅ Only logs non-sensitive information
❌ No major refactoring required

2. Fix in LoggerUtility.java (Minimal Change)

Instead of modifying all logging calls, just prevent sensitive data from being logged at the entry point.

Option 1: Mask sensitive data directly before logging

Modify the info() method:

public void info(String format, Object... arguments) {
    setMDC(); // Maintain MDC context
    
    // Mask sensitive arguments
    for (int i = 0; i < arguments.length; i++) {
        if (arguments[i] instanceof String && containsSensitiveData((String) arguments[i])) {
            arguments[i] = "****";  // Mask data
        }
    }

    logger.info(format, arguments);
}

private boolean containsSensitiveData(String data) {
    return data.toLowerCase().contains("key") || data.toLowerCase().contains("password");
}

✅ Minimal changes
✅ Only masks sensitive data dynamically before logging

3. Alternative Quick Fix (Disable Sensitive Logging via Logging Framework)

If your project uses logback, you can filter out sensitive logs without changing code:

logback.xml (Quick Config Fix)

Add a filter to ignore logs containing sensitive keywords:

<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.EvaluatorFilter">
            <evaluator>
                <expression>!(message.contains("key") || message.contains("password"))</expression>
            </evaluator>
            <onMatch>DENY</onMatch>
            <onMismatch>NEUTRAL</onMismatch>
        </filter>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    <root level="info">
        <appender-ref ref="STDOUT" />
    </root>
</configuration>

✅ No Java code changes
✅ Filters logs dynamically
✅ Easy to revert if needed

Final Recommendation
	•	If you can modify the log statements, remove sensitive fields (Best option).
	•	If you want minimal code change, mask sensitive values dynamically in LoggerUtility.java.
	•	If you want zero code changes, use a logging framework filter.

Would you prefer the quick fix in code or via logback.xml?


