public TransactionResponse<CustomerResponse> updateCustomerStatus(String customerId, String status) {
    logger.debug(" updateCustomerStatus for customerId {} and status{}", customerId, status);
    
    CustomerDto customerDto = customerDao.getCustomerByCustomerId(customerId)
            .orElseThrow(() -> new TransactionException(CustomerErrorConstant.NOT_FOUND_ERROR_CODE,
                    MessageFormat.format(CustomerErrorConstant.NOT_FOUND_ERROR_MESSAGE, TransactionConstant.VALID_CUSTOMER)));
    
    logger.debug("customerDto {}", customerDto);
    
    // Prevent status update if current status is "D" (Deleted)
    if ("D".equals(customerDto.getStatus()) && !"D".equals(status)) {
        throw new TransactionException(CustomerErrorConstant.INVALID_ERROR_CODE, 
                "Cannot change status from 'Delete' to '" + status + "'");
    }

    EncryptionKeyDto encryptionKeyDto = kmsServiceClient.getKekAndMekByMID(EPayIdentityUtil.getUserPrincipal().getMId());

    switch (status) {
        case "active" -> customerDto.setStatus("A");
        case "inactive" -> customerDto.setStatus("I");
        case "delete" -> customerDto.setStatus("D");
        case "blocked" -> customerDto.setStatus("B");
        default ->
                throw new TransactionException(CustomerErrorConstant.INVALID_ERROR_CODE, 
                        MessageFormat.format(CustomerErrorConstant.INVALID_ERROR_MESSAGE, "customer status"));
    }

    // Update customer status
    logger.info("update customer status");
    customerDao.updateCustomerStatus(customerDto);
    
    String encryptedResponse = customerUtil.encryptCustomerData(customerDto, encryptionKeyDto);
    logger.debug("encrypted customerResponse{}", encryptedResponse);
    
    return CustomerUtil.buildTransactionResponse(encryptedResponse);
}





public TransactionResponse<CustomerResponse> updateCustomerStatus(String customerId, String status) {
logger.debug(" updateCustomerStatus for customerId {} and status{}",customerId,customerId);
        CustomerDto customerDto = customerDao.getCustomerByCustomerId(customerId)
                .orElseThrow(() -> new TransactionException(CustomerErrorConstant.NOT_FOUND_ERROR_CODE,
                        MessageFormat.format(CustomerErrorConstant.NOT_FOUND_ERROR_MESSAGE, TransactionConstant.VALID_CUSTOMER)));
        logger.debug("customerDto {}",customerDto);
        EncryptionKeyDto encryptionKeyDto = kmsServiceClient.getKekAndMekByMID(EPayIdentityUtil.getUserPrincipal().getMId());

        switch (status) {
            case "active" -> customerDto.setStatus("A");
            case "inactive" -> customerDto.setStatus("I");
            case "delete" -> customerDto.setStatus("D");
            case "blocked" -> customerDto.setStatus("B");
            default ->
                    throw new TransactionException(CustomerErrorConstant.INVALID_ERROR_CODE, MessageFormat.format(CustomerErrorConstant.INVALID_ERROR_MESSAGE, "customer status"));
        };


      //update customer status
        logger.info("update customer status");
        customerDao.updateCustomerStatus(customerDto);
        String encryptedResponse = customerUtil.encryptCustomerData(customerDto, encryptionKeyDto);
logger.debug("encrypted customerResponse{}",encryptedResponse);
        return CustomerUtil.buildTransactionResponse(encryptedResponse);
    }


@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString
@Builder
public class CustomerDto extends BaseDto {

    private String merchantId;
    private String customerId;
    private String customerName;
    private String email;
    private String gstIn;
    private String gstInAddress;
    private String phoneNumber;
    private String address1;
    private String address2;
    private String city;
    private String state;
    private String country;
    private String pinCode;
    private String status;

}








    /**
     * Update customer status
     *
     * @param customerDto
     * @return CustomerDto
     */
public CustomerDto updateCustomerStatus(CustomerDto customerDto) {
    MerchantCustomer merchantCustomer= customerRepository.save(customerMapper.customerDtoToEntity(customerDto));
    return customerMapper.customerEntityToDto(merchantCustomer);
}
