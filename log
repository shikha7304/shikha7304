package com.epay.merchant.service;

import com.epay.merchant.dao.ThemeDao;
import com.epay.merchant.dto.ThemeDto;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.validator.ThemeValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

import static com.epay.merchant.util.MerchantUtil.getBase64;

/**
 * Class Name: ThemeService
 * *
 * Description: To handle the theme business logic.
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class ThemeService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final ThemeValidator themeValidator;
    private final ThemeDao themeDao;

    /**
     * createPaymentPageTheme
     *
     * @param logoFile       MultipartFile
     * @param mId            String
     * @param primaryColor   String
     * @param secondaryColor String
     * @return MerchantResponse
     */
    public MerchantResponse<ThemeDto> createPaymentPageTheme(MultipartFile logoFile, String mId, String primaryColor, String secondaryColor) {
        ThemeDto paymentPageTheme = saveTheme(logoFile, mId, primaryColor, secondaryColor, false);
        log.debug("createPaymentPageTheme completed with theme {}", paymentPageTheme);
        return MerchantResponse.<ThemeDto>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(paymentPageTheme)).count(1L).total(1L).build();
    }

    /**
     * updatePaymentPageTheme
     *
     * @param logoFile       MultipartFile
     * @param mId            String
     * @param primaryColor   String
     * @param secondaryColor String
     * @return MerchantResponse
     */
    public MerchantResponse<ThemeDto> updatePaymentPageTheme(MultipartFile logoFile, String mId, String primaryColor, String secondaryColor) {
        ThemeDto paymentPageTheme = saveTheme(logoFile, mId, primaryColor, secondaryColor, true);
        return MerchantResponse.<ThemeDto>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(paymentPageTheme)).count(1L).total(1L).build();
    }

    /**
     * Get PaymentPageTheme by MID.
     *
     * @param mId String
     * @return MerchantResponse
     */
    public MerchantResponse<ThemeDto> getPaymentPageTheme(String mId) {
        themeValidator.validatedMIdGetTheme(mId);
        ThemeDto themeDto = themeDao.findTheme(mId, MerchantConstant.THEME_PAYMENT);
        return MerchantResponse.<ThemeDto>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(themeDto)).count(1L).total(1L).build();
    }

    /**
     * Create ThemeDto object
     *
     * @param mId            String
     * @param logoFile       MultipartFile
     * @param primaryColor   String
     * @param secondaryColor String
     * @return ThemeDto
     */
    private ThemeDto buildPaymentPageThemeDto(String mId, MultipartFile logoFile, String primaryColor, String secondaryColor) {
        return ThemeDto.builder().mId(mId).logo(getBase64(logoFile)).primaryColor(primaryColor).secondaryColor(secondaryColor).module(MerchantConstant.THEME_PAYMENT).build();
    }
    /**
     * Save saveTheme object
     *
     * @param logoFile            String
     * @param mId       MultipartFile
     * @param primaryColor   String
     * @param secondaryColor String
     * @param isUpdate   boolean
     * @return ThemeDto
     */
    private ThemeDto saveTheme(MultipartFile logoFile, String mId, String primaryColor, String secondaryColor, boolean isUpdate) {
        ThemeDto themeDto = buildPaymentPageThemeDto(mId, logoFile, primaryColor, secondaryColor);
        themeValidator.validateLogo(logoFile, isUpdate);
        if (isUpdate) {
            themeValidator.validateUpdateRequest(themeDto);
            return themeDao.updatePaymentPageTheme(themeDto);
        }
        themeValidator.validateSaveRequest(themeDto);
        return themeDao.createPaymentPageTheme(themeDto);
    }
}


package com.epay.merchant.service;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.TokenDao;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.entity.TokenManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.util.DateTimeUtils;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.TokenStatus;
import com.epay.merchant.util.enums.UserStatus;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.service.AuthenticationService;
import com.sbi.epay.authentication.util.enums.TokenType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class TokenService {

    final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final AuthenticationService authenticationService;
    private final TokenDao tokenDao;
    private final MerchantConfig merchantConfig;

    /**
     * This method will generate the user token and update the merchant user login status in DB
     * @param userName String
     * @return Token String
     */
    @Transactional
    public String generateUserToken(String userName) {
        // Step 1 : Get the User
        MerchantUserDto merchantUserDto = tokenDao.getMerchantUserDto(userName);

        // Step 2 : Save Initial Token Request
        TokenManagement tokenManagement = tokenDao.saveInitialToken(merchantUserDto.getId());

        // Step 3 : Generate User Token Request
        String token = generateUserToken(tokenManagement, merchantUserDto);

        //Step 4 : Update Merchant User Login Status
        tokenDao.updateMerchantUserForLogin(merchantUserDto, true);
        return token;

    }

    /**
     *This method will update the login status detail for a given userName
     * @param userName String
     * @param loginStatus  boolean
     */
    public int updateMerchantUserForLogin(String userName, boolean loginStatus) {
        MerchantUserDto merchantUserDto = tokenDao.getMerchantUserDto(userName, List.of(UserStatus.values()));
        if(UserStatus.ACTIVE.equals(merchantUserDto.getStatus())) {
            return tokenDao.updateMerchantUserForLogin(merchantUserDto, loginStatus);
        }
        return 0;
    }

    /**
     * Invalidates the token for the specified username.
     * @param userName Username of the merchant user.
     * @return Integer representing success or failure status.
     */
    public int invalidateUserToken(String userName) {
        MerchantUserDto merchantUserDto = tokenDao.getMerchantUserDto(userName);
        Optional<TokenManagement> validToken = tokenDao.findTokenByUserIdAndIsValidTrue(merchantUserDto.getId());
        if (validToken.isPresent()) {
            TokenManagement tokenManagement = validToken.get();
            tokenManagement.setValid(false);
            tokenDao.saveToken(List.of(tokenManagement));
            return MerchantConstant.RESPONSE_SUCCESS;
        }
        return MerchantConstant.RESPONSE_FAILURE;
    }

    /**
     * It will call the authentication utility to generate the token
     * @param tokenManagement TokenManagement
     * @param merchantUser MerchantUserDto
     * @return  Token
     */
    @Transactional
    private String generateUserToken(TokenManagement tokenManagement, MerchantUserDto merchantUser) {
        try {
            log.info("Going to call authentication utility to generate the token for userId: {}", merchantUser.getUserName());
            List<TokenManagement> tokenManagements = new ArrayList<>();
            updateExistingToken(merchantUser, tokenManagements);
            String token = generateUserToken(tokenManagement, merchantUser, tokenManagements);
            tokenDao.saveToken(tokenManagements);
            return token;
        } catch (Exception e) {
            // Handle token generation failure
            log.error("Token generation failed for userId: {}, Exception: {}", merchantUser.getUserName(), e.getMessage());
            tokenManagement.setTokenStatus(TokenStatus.GENERATION_FAIL);
            tokenManagement.setRemarks(TokenStatus.GENERATION_FAIL.remarks + " : " + e.getMessage());
            tokenDao.saveToken(List.of(tokenManagement));
            tokenDao.updateMerchantUserForLogin(merchantUser, false);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "Token"));
        }
    }

    /**
     * This method generates the user token for a given user
     * @param merchantUser MerchantUserDto
     * @param tokenManagement TokenManagement
     * @param tokenManagements List<TokenManagement>
     * @return  token
     */
    private String generateUserToken(TokenManagement tokenManagement, MerchantUserDto merchantUser, List<TokenManagement> tokenManagements) {
        String token = authenticationService.generateUserToken(buildUserTokenRequest(merchantUser));
        tokenManagement.setToken(token);
        tokenManagement.setTokenStatus(TokenStatus.GENERATED);
        tokenManagement.setTokenExpiryTime(DateTimeUtils.addMinutes(merchantConfig.getTokenExpiryTime() - 1));
        tokenManagement.setValid(true);
        tokenManagement.setRemarks(TokenStatus.GENERATED.remarks);
        tokenManagements.add(tokenManagement);
        return token;
    }

    /**
     * This method will validate the token if exists then update the token status
     * @param merchantUser MerchantUserDto
     * @param tokenManagements List<TokenManagement>
     */
    private void updateExistingToken(MerchantUserDto merchantUser, List<TokenManagement> tokenManagements) {
        Optional<TokenManagement> existingToken = tokenDao.findTokenByUserIdAndIsValidTrue(merchantUser.getId());
        if (existingToken.isPresent()) {
            TokenManagement existingTokenData = existingToken.get();
            existingTokenData.setTokenStatus(TokenStatus.INVALIDATED);
            existingTokenData.setTokenExpiryTime(System.currentTimeMillis());
            existingTokenData.setValid(false);
            existingTokenData.setRemarks(TokenStatus.INVALIDATED.remarks);
            tokenManagements.add(existingTokenData);
        }
    }

    /**
     * This method will build the token request for given user
     * @param merchantUser MerchantUserDto
     * @return  tokenRequest
     */
    private UserTokenRequest buildUserTokenRequest(MerchantUserDto merchantUser) {
        UserTokenRequest tokenRequest = new UserTokenRequest();
        tokenRequest.setTokenType(TokenType.USER);
        tokenRequest.setUsername(merchantUser.getUserName());
        tokenRequest.setPassword(merchantUser.getPassword());
        tokenRequest.setRoles(List.of(tokenDao.getMerchantUserRoleName(merchantUser.getRole())));
        tokenRequest.setExpirationTime(DateTimeUtils.addMinutes(merchantConfig.getTokenExpiryTime() - 1));
        return tokenRequest;
    }

}
