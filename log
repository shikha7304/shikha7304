/**
 * Service class handling password-related operations such as password change and reset.
 * Contains validation and database update logic for secure password management.
 */
@Service
@RequiredArgsConstructor
public class PasswordService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final PasswordValidator passwordValidator;
    private final PasswordManagementDao passwordManagementDao;
    private final MerchantConfig merchantConfig;

    /**
     * Handles the password change process for a user.
     *
     * Steps:
     * 1. Validate mandatory fields in the request.
     * 2. Decrypt the new and confirm passwords.
     * 3. Validate the password change request, including user and password verification.
     * 4. Update the password details in the database.
     * 5. Return a success response.
     *
     * @param passwordChangeRequest Request object containing userName, oldPassword, and newPassword.
     * @return A success response with a message confirming password change.
     */
    public MerchantResponse<String> changePassword(PasswordChangeRequest passwordChangeRequest) {
        try {
            log.info("Starting password change process for user: {}", passwordChangeRequest.getUserName());
            passwordValidator.validateMandatoryFields(passwordChangeRequest);
            log.info("Validated mandatory fields for password change request.");

            passwordChangeRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getNewPassword()));
            passwordChangeRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getConfirmPassword()));
            log.info("Decrypted new and confirm passwords for password change request.");

            validatePasswordChange(passwordChangeRequest);
            log.info("Validated password change request for user: {}", passwordChangeRequest.getUserName());

            passwordManagementDao.updatePasswordDetails(passwordChangeRequest.getUserName(), passwordChangeRequest.getNewPassword(), List.of(UserStatus.EXPIRED), RequestType.CHANGE_PASSWORD);
            log.info("Updated password in the database for user: {}", passwordChangeRequest.getUserName());

            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Changed Successfully")).count(1L).total(1L).build();
        } catch (Exception e) {
            log.error("Password change request failed for user: {}", passwordChangeRequest.getUserName(), e);
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getMessage());
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Handles the password reset process for a user.
     *
     * Steps:
     * 1. Validate mandatory fields in the reset request.
     * 2. Decrypt the new and confirm passwords.
     * 3. Validate the password reset request.
     * 4. Update the password details in the database.
     * 5. Return a success response.
     *
     * @param passwordResetRequest Request object containing userName, newPassword, and confirmPassword.
     * @return A success response with a message confirming password reset.
     */
    public MerchantResponse<String> resetPassword(PasswordResetRequest passwordResetRequest) {
        try {
            log.info("Starting password reset process for user: {}", passwordResetRequest.getUserName());
            passwordValidator.validateMandatoryFields(passwordResetRequest);
            log.info("Validated mandatory fields for password reset request.");

            passwordResetRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getNewPassword()));
            passwordResetRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getConfirmPassword()));
            log.info("Decrypted new and confirm passwords for password reset request.");

            validatePasswordReset(passwordResetRequest);
            log.info("Validated password reset request for user: {}", passwordResetRequest.getUserName());

            passwordManagementDao.updatePasswordDetails(passwordResetRequest.getUserName(), passwordResetRequest.getNewPassword(), List.of(UserStatus.ACTIVE), RequestType.RESET_PASSWORD);
            log.info("Updated password in the database for user: {}", passwordResetRequest.getUserName());

            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Reset Successfully")).count(1L).total(1L).build();
        } catch (Exception e) {
            log.error("Password reset request failed for user: {}", passwordResetRequest.getUserName(), e);
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getMessage());
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Validates the password change request for a user.
     *
     * @param passwordChangeRequest The request object containing userName, oldPassword, and newPassword.
     */
    private void validatePasswordChange(PasswordChangeRequest passwordChangeRequest) {
        log.info("Validating password change request for user: {}", passwordChangeRequest.getUserName());
        passwordValidator.validatePasswordValue(passwordChangeRequest.getNewPassword(), passwordChangeRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordChangeRequest.getUserName(), List.of(UserStatus.EXPIRED));
        String passwordHashValue = hashValue(passwordChangeRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue, passwordChangeRequest.getOldPassword());
        log.info("Successfully validated password change request for user: {}", passwordChangeRequest.getUserName());
    }

    /**
     * Validates the password reset request for a user.
     *
     * @param passwordResetRequest The request object containing userName, newPassword, and confirmPassword.
     */
    private void validatePasswordReset(PasswordResetRequest passwordResetRequest) {
        log.info("Validating password reset request for user: {}", passwordResetRequest.getUserName());
        passwordValidator.validatePasswordValue(passwordResetRequest.getNewPassword(), passwordResetRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordResetRequest.getUserName(), List.of(UserStatus.ACTIVE));
        String passwordHashValue = hashValue(passwordResetRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue);
        log.info("Successfully validated password reset request for user: {}", passwordResetRequest.getUserName());
    }

    /**
     * Handles password operation failures by saving an audit log.
     *
     * @param userName    The username associated with the failure.
     * @param requestType The type of password operation (change/reset).
     * @param error       The error message to log.
     */
    private void handlePasswordFailure(String userName, RequestType requestType, String error) {
        log.info("Handling password failure for user: {}, RequestType: {}", userName, requestType);
        if (StringUtils.isNotEmpty(userName)) {
            try {
                passwordManagementDao.saveAudit(userName, requestType, false, error);
                log.info("Password failure audit logged for user: {}, RequestType: {}", userName, requestType);
            } catch (Exception ex) {
                log.error("Failed to log password failure audit for user: {}, RequestType: {}", userName, requestType, ex);
            }
        }
    }
}


/**
 * Service class for handling user authentication and token validation.
 */
public class SecurityService implements AuthenticationUserService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final TokenDao tokenDao;
    private final MerchantUserDao merchantUserDao;

    /**
     * Loads user details based on the provided username.
     *
     * This method retrieves user information from the database and wraps it in an `EPayPrincipal` object.
     * It is primarily used for authentication purposes.
     *
     * @param userName The username of the user whose details are to be loaded.
     * @return An `Optional` containing the `EPayPrincipal` object if the user exists.
     */
    @Override
    public Optional<EPayPrincipal> loadUserByUserName(String userName) {
        log.info("Loading user details for username: {}", userName);
        try {
            MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
            EPayPrincipal authenticateEntity = new EPayPrincipal();
            authenticateEntity.setAuthenticationId(merchantUserDto.getUserName());
            log.info("Successfully loaded user details for username: {}", userName);
            return Optional.of(authenticateEntity);
        } catch (Exception e) {
            log.error("Failed to load user details for username: {}", userName, e);
            return Optional.empty();
        }
    }

    /**
     * Validates whether the provided token is valid.
     *
     * This method checks the token's existence and validity using the `TokenDao`.
     *
     * @param token The token to be validated.
     * @return `true` if the token is invalid, `false` if the token is valid.
     */
    @Override
    public boolean isTokenInValid(String token) {
        log.info("Validating token: {}", token);
        try {
            boolean isInvalid = !tokenDao.isValidTokenExist(token);
            log.info("Token validation result for token {}: {}", token, isInvalid ? "Invalid" : "Valid");
            return isInvalid;
        } catch (Exception e) {
            log.error("Error occurred while validating token: {}", token, e);
            return true; // Return invalid if an error occurs.
        }
    }
}





package com.epay.merchant.service;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dao.PasswordManagementDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.request.PasswordChangeRequest;
import com.epay.merchant.model.request.PasswordResetRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.RequestType;
import com.epay.merchant.util.enums.UserStatus;
import com.epay.merchant.validator.PasswordValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

import static com.epay.merchant.util.EncryptionDecryptionUtil.decryptValue;
import static com.epay.merchant.util.EncryptionDecryptionUtil.hashValue;

/**
 * Class Name: PasswordService
 * *
 * Description:
 * *
 * Author: Subhra Goswami
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class PasswordService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final PasswordValidator passwordValidator;
    private final PasswordManagementDao passwordManagementDao;
    private final MerchantConfig merchantConfig;

    /**
     * Method to handle the password change logic
     * @param passwordChangeRequest PasswordChangeRequest
     */
    public MerchantResponse<String> changePassword(PasswordChangeRequest passwordChangeRequest) {
        try {
            log.info("Starting password change process for user: {}", passwordChangeRequest.getUserName());
            // Step 1: Validate mandatory password reset request
            passwordValidator.validateMandatoryFields(passwordChangeRequest);
            log.info("Password change request validated successfully for mandatory field");

            // Step 2 : Decrypt Password
            passwordChangeRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getNewPassword()));
            passwordChangeRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordChangeRequest.getConfirmPassword()));
            log.info("Password change request decrypted successfully");

            // Step 3: Validate the password change request
            validatePasswordChange(passwordChangeRequest);
            log.info("Password change request validated successfully");

            // Step 4: Update the password details in the database
            passwordManagementDao.updatePasswordDetails(passwordChangeRequest.getUserName(), passwordChangeRequest.getNewPassword(), List.of(UserStatus.EXPIRED), RequestType.CHANGE_PASSWORD);

            // Step 5: Build and return the success response
            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Changed Successfully")).count(1L).total(1L).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> ErrorConstants.MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("Password Change Request Validation Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw e;
        } catch (MerchantException e) {
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getErrorMessage());
            log.error("Password Change Request Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw e;
        } catch (Exception e) {
            handlePasswordFailure(passwordChangeRequest.getUserName(), RequestType.CHANGE_PASSWORD, e.getLocalizedMessage());
            log.error("Password Change Request Failed for PasswordChangeRequest {} ", passwordChangeRequest);
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Method to handle the reset password logic
     * @param passwordResetRequest PasswordResetRequest
     */
    public MerchantResponse<String> resetPassword(PasswordResetRequest passwordResetRequest) {
        try {
            log.info("Starting password reset process for user: {}", passwordResetRequest.getUserName());
            // Step 1: Validate mandatory password reset request
            passwordValidator.validateMandatoryFields(passwordResetRequest);
            log.info("Password reset request validated successfully for mandatory field");

            // Step 2 : Decrypt Password
            passwordResetRequest.setNewPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getNewPassword()));
            passwordResetRequest.setConfirmPassword(decryptValue(merchantConfig.getDecryptionKey(), passwordResetRequest.getConfirmPassword()));
            log.info("Password reset request decrypted successfully");

            // Step 3: Validate the password reset request
            validatePasswordReset(passwordResetRequest);
            log.info("Password reset request validated successfully");

            // Step 4: Update the password details in the database
            passwordManagementDao.updatePasswordDetails(passwordResetRequest.getUserName(), passwordResetRequest.getNewPassword(), List.of(UserStatus.ACTIVE), RequestType.RESET_PASSWORD);

            // Step 5: Build and return the success response
            return MerchantResponse.<String>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of("Password Reset Successfully")).count(1L).total(1L).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> ErrorConstants.MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")));
            log.error("Password Reset Request Validation Failed for passwordResetRequest {} ", passwordResetRequest);
            throw e;
        } catch (MerchantException e) {
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getErrorMessage());
            log.error("Password Reset Request Failed for passwordResetRequest {} ", passwordResetRequest);
            throw e;
        } catch (Exception e) {
            handlePasswordFailure(passwordResetRequest.getUserName(), RequestType.RESET_PASSWORD, e.getLocalizedMessage());
            log.error("Password Reset Request Failed for passwordResetRequest {} ", passwordResetRequest);
            throw new MerchantException(ErrorConstants.GENERIC_ERROR_CODE, ErrorConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * Method to validate the user status and create hash password and update in DB
     * @param passwordChangeRequest PasswordChangeRequest
     */
    private void validatePasswordChange(PasswordChangeRequest passwordChangeRequest) {
        log.info("Validating password change request for user: {}", passwordChangeRequest.getUserName());
        passwordValidator.validatePasswordValue(passwordChangeRequest.getNewPassword(), passwordChangeRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordChangeRequest.getUserName(), List.of(UserStatus.EXPIRED));
        String passwordHashValue = hashValue(passwordChangeRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue, passwordChangeRequest.getOldPassword());
    }

    /**
     * Method to validate the reset password logic
     * @param passwordResetRequest PasswordResetRequest
     */
    private void validatePasswordReset(PasswordResetRequest passwordResetRequest) {
        passwordValidator.validatePasswordValue(passwordResetRequest.getNewPassword(), passwordResetRequest.getConfirmPassword());
        MerchantUserDto merchantUser = passwordManagementDao.findByUserNameOrEmailOrMobilePhoneAndStatus(passwordResetRequest.getUserName(), List.of(UserStatus.ACTIVE));
        String passwordHashValue = hashValue(passwordResetRequest.getNewPassword());
        passwordValidator.validatePasswordUpdateWithDB(merchantUser, passwordHashValue);
    }

    /**
     * Method to handle password failure logic
     * @param userName String
     * @param requestType RequestType
     * @param e String
     */
    private void handlePasswordFailure(String userName, RequestType requestType, String e) {
        if (StringUtils.isNotEmpty(userName)) {
            try {
                passwordManagementDao.saveAudit(userName, requestType, false, e);
            } catch (MerchantException ex) {
                log.error("Error in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getErrorMessages());
            } catch (Exception ex) {
                log.error("Error in handlePasswordFailure for userName {}, RequestType {} ", userName, requestType, ex.getMessage());
            }
        }
    }
}


public class SecurityService implements AuthenticationUserService {

    private final TokenDao tokenDao;
    private final MerchantUserDao merchantUserDao;


    /**
     This method will call the authenticateEntity to authenticate and get the userName by token
     @param userName String
     */
    @Override
    public Optional<EPayPrincipal> loadUserByUserName(String userName) {
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        EPayPrincipal authenticateEntity = new EPayPrincipal();
        authenticateEntity.setAuthenticationId(merchantUserDto.getUserName());
        return Optional.of(authenticateEntity);
    }
    /**
     * It will check if the token is valid or not
     */
    @Override
    public boolean isTokenInValid(String token) {
        return !tokenDao.isValidTokenExist(token);
    }
}
