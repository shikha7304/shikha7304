Defect: To Verify error message when user send invalid Request ID

Method: Post2. .API: {base url}/merchant/v1/captcha{ "requestType":"LOGIN", "requestId":"31529ddf-ce3f-4547-a4c4-e741c893b81g"}

Actual Response
Status: 400 Bad Request {     "status": 0,     "errors": [         {             "errorCode": "400",             "errorMessage": "JSON parse error: Cannot deserialize value of type java.util.UUID from String "82629ddf-bc3f-4547-a4c4-e741c893b81d-e741c893b81d": UUID has to be represented by standard 36-char representation"         }     ] }

Expected response
Status should be displayed 200 OK and also show proper error message for invalid request id.

what all changes we need to do to achive this expected response as per my code 




The issue is caused by Spring Boot’s default deserialization mechanism when parsing the requestId. The error occurs because the given requestId is not a valid UUID format. By default, Spring Boot fails to parse invalid UUIDs and returns a 400 Bad Request with an internal JSON parse error.

Steps to Achieve Expected Response (200 OK with Proper Error Message)

1. Modify the DTO to Handle Invalid UUIDs Gracefully
	•	Instead of directly mapping requestId to a UUID field, use String and validate manually.

Before (Current Implementation)

public class CaptchaRequestDto {
    private UUID requestId;
    private String requestType;
}

After (Updated Implementation)

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class CaptchaRequestDto {
    
    @NotBlank(message = "Request ID cannot be blank")
    private String requestId;

    @NotBlank(message = "Request Type cannot be blank")
    private String requestType;
}

2. Add a Custom Validator for UUID Format
	•	Since requestId is now a String, we need to validate if it is a properly formatted UUID.

Create a Utility Class for Validation

import java.util.UUID;

public class ValidationUtil {
    public static boolean isValidUUID(String requestId) {
        try {
            UUID.fromString(requestId);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}

3. Update Controller to Validate the Request ID

Modify the controller method to validate requestId before processing the request.

Before (Current Implementation)

@PostMapping("/merchant/v1/captcha")
public ResponseEntity<?> generateCaptcha(@RequestBody CaptchaRequestDto captchaRequest) {
    // Process request directly
}

After (Updated Implementation)

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/merchant/v1")
public class CaptchaController {

    @PostMapping("/captcha")
    public ResponseEntity<?> generateCaptcha(@RequestBody CaptchaRequestDto captchaRequest) {
        if (!ValidationUtil.isValidUUID(captchaRequest.getRequestId())) {
            return ResponseEntity.ok(new ErrorResponse("Invalid Request ID format. It should be a valid UUID."));
        }

        // Proceed with normal captcha generation logic
        return ResponseEntity.ok(new SuccessResponse("Captcha generated successfully"));
    }
}

4. Define a Custom Error Response Class

Create a consistent error response format.

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ErrorResponse {
    private String errorMessage;
}

5. Expected Behavior After Fix

Input (Invalid requestId)

{
    "requestType": "LOGIN",
    "requestId": "31529ddf-ce3f-4547-a4c4-e741c893b81g"
}

Response (200 OK)

{
    "errorMessage": "Invalid Request ID format. It should be a valid UUID."
}

Summary of Changes
	1.	Changed requestId in DTO from UUID to String to prevent automatic parsing errors.
	2.	Added a UUID format validation utility (ValidationUtil).
	3.	Updated the controller to validate requestId manually and return a proper error message.
	4.	Created a consistent error response format (ErrorResponse class).
	5.	Now, the API will always return 200 OK with a proper error message instead of 400 Bad Request
Would you like me to adjust the error structure to match your existing error format?



Yes, you can achieve the expected behavior with minimum changes by using a custom exception handler and keeping the DTO unchanged. Here’s what you need to do:

Minimal Changes to Fix the Issue

1. Keep DTO as it is (No Change)

public class CaptchaRequestDto {
    private UUID requestId;
    private String requestType;
}

2. Add a Global Exception Handler to Catch the UUID Parsing Error

Spring Boot throws a MethodArgumentNotValidException or HttpMessageNotReadableException when it fails to deserialize an invalid UUID. We can handle this globally.

Create or Modify Global Exception Handler

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidFormatException.class)
    public ResponseEntity<?> handleInvalidUUIDException(InvalidFormatException ex) {
        if (ex.getTargetType() == UUID.class) {
            return ResponseEntity.ok(new ErrorResponse("Invalid Request ID format. It should be a valid UUID."));
        }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse("Invalid request format."));
    }
}

3. Define a Simple Error Response Class

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ErrorResponse {
    private String errorMessage;
}

Expected Behavior After Fix

Input (Invalid requestId)

{
    "requestType": "LOGIN",
    "requestId": "31529ddf-ce3f-4547-a4c4-e741c893b81g"
}

Response (200 OK)

{
    "errorMessage": "Invalid Request ID format. It should be a valid UUID."
}

Why Is This the Minimal Change Approach?

✅ No changes to DTO – requestId remains UUID.
✅ No changes to controller – Existing logic remains intact.
✅ Just one centralized exception handler – It catches UUID parsing errors and returns a 200 OK with a proper message.

This should work without modifying the existing request-handling logic. Let me know if you need further refinements!

package com.epay.merchant.exceptionhandlers;

import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.sbi.epay.encryptdecrypt.exception.EncryptionDecryptionException;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.ConstraintViolationException;
import org.hibernate.exception.SQLGrammarException;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.util.CollectionUtils;
import org.springframework.web.ErrorResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.util.List;
import java.util.UUID;

/**
 * Class Name: MerchantExceptionHandler
 * <p>
 * Description:This class is used to handle exceptions globally within the application,
 * specifically for handling exceptions related to merchant operations.
 * It leverages Spring's @ControllerAdvice annotation to provide centralized
 * exception handling across all controllers.
 * <p>
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@ControllerAdvice
public class MerchantExceptionHandler extends ResponseEntityExceptionHandler {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * @param ex MerchantException
     * @return ResponseEntity
     */
    @ExceptionHandler(value = {MerchantException.class, EncryptionDecryptionException.class})
    public ResponseEntity<Object> handleEPayServiceException(RuntimeException ex) {
        ErrorDto errorDto;
        switch (ex) {
            case MerchantException me ->
                    errorDto = ErrorDto.builder().errorCode(me.getErrorCode()).errorMessage(me.getErrorMessage()).build();
            case EncryptionDecryptionException me ->
                    errorDto = ErrorDto.builder().errorCode(me.getErrorCode()).errorMessage(me.getErrorMessage()).build();
            default ->
                    errorDto = ErrorDto.builder().errorCode(ErrorConstants.GENERIC_ERROR_CODE).errorMessage(ex.getLocalizedMessage()).build();
        }
        return generateResponseWithErrors(List.of(errorDto));
    }

    /**
     * Handle ValidationException
     *
     * @param ex ValidationException
     * @return ResponseEntity
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Object> handleValidationException(ValidationException ex) {
        if (CollectionUtils.isEmpty(ex.getErrorMessages())) {
            ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
            return generateResponseWithErrors(List.of(errorDto));
        }
        return generateResponseWithErrors(ex.getErrorMessages());
    }

    /**
     * Handle handleDBException exception
     *
     * @param ex DataAccessException
     * @return ResponseEntity
     */
    @ExceptionHandler(value = {DataAccessException.class, DataIntegrityViolationException.class, ConstraintViolationException.class, SQLGrammarException.class})
    public ResponseEntity<Object> handleDBException(Exception ex) {
        String errorMessage;
        switch (ex) {
            case DataIntegrityViolationException de -> errorMessage = de.getMostSpecificCause().getMessage();
            case DataAccessException de -> errorMessage = de.getMostSpecificCause().getMessage();
            case ConstraintViolationException de -> errorMessage = de.getConstraintViolations().toString();
            case SQLGrammarException de -> errorMessage = de.getLocalizedMessage();
            default -> errorMessage = ex.getMessage();
        }
        logger.error("Error in handleDBException ", errorMessage);
        ErrorDto errorDto = ErrorDto.builder().errorCode(ErrorConstants.GENERIC_ERROR_CODE).errorMessage(errorMessage).build();
        return ResponseEntity.internalServerError().body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {AuthorizationDeniedException.class})
    public ResponseEntity<Object> handleAuthorizationDeniedException(AuthorizationDeniedException ex) {
        logger.error("Error in handleAuthorizationDeniedException ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(String.valueOf(HttpStatus.FORBIDDEN.value())).errorMessage(ex.getMessage() + ": Not having the necessary permissions to access this resources").build();
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    /**
     * Handle general exception
     *
     * @param ex Exception
     * @return ResponseEntity
     */
    @ExceptionHandler(value = {Exception.class})
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        logger.error("Error in handleGenericException ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value())).errorMessage(ex.getMessage()).build();
        return ResponseEntity.internalServerError().body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    /**
     * Handle Runtime exception
     *
     * @param ex RuntimeException
     * @return ResponseEntity
     */
    @ExceptionHandler(value = {IllegalArgumentException.class, IllegalStateException.class})
    protected ResponseEntity<Object> handleConflict(RuntimeException ex) {
        logger.error("Error in handleConflict ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(String.valueOf(HttpStatus.CONFLICT.value())).errorMessage(ex.getLocalizedMessage()).build();
        return ResponseEntity.status(HttpStatus.CONFLICT).body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @Override
    protected ResponseEntity<Object> handleExceptionInternal(Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatusCode statusCode, WebRequest request) {
        if (request instanceof ServletWebRequest servletWebRequest) {
            HttpServletResponse response = servletWebRequest.getResponse();
            if (response != null && response.isCommitted()) {
                return null;
            }
        }
        ErrorDto errorDto = ErrorDto.builder().errorCode(String.valueOf(statusCode.value())).errorMessage(ex.getLocalizedMessage()).build();
        return ResponseEntity.status(statusCode).body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    /**
     * Preparing errors in API response object.
     *
     * @param errors List
     * @return ResponseEntity
     */
    private ResponseEntity<Object> generateResponseWithErrors(List<ErrorDto> errors) {
        return ResponseEntity.ok().body(MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(errors).build());
    }

    /**
     * Handle ValidationException
     *
     * @param ex ValidationException
     * @return ResponseEntity
     */
    @ExceptionHandler(InvalidFormatException.class)
    public ResponseEntity<?> handleInvalidUUIDException(InvalidFormatException ex) {
        if (ex.getTargetType() == UUID.class) {
            ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ErrorConstants.INVALID_ERROR_CODE).;
    }

}

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class ErrorConstants {

    public static final String MANDATORY_ERROR_CODE = "7001";
    public static final String MANDATORY_ERROR_MESSAGE = "{0} is mandatory.";

    public static final String NOT_FOUND_ERROR_CODE = "7003";
    public static final String NOT_FOUND_ERROR_MESSAGE = "{0} is not found.";
    public static final String LOGIN_USER_NOT_FOUND_ERROR_MESSAGE = "Invalid User -> Please check UserName and Password";

    public static final String INVALID_ERROR_CODE = "7002";
    public static final String INVALID_ERROR_MESSAGE = "Invalid {0}. Reason : {1}";

