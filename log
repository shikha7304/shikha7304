package com.epay.merchant.service;

import com.epay.merchant.dao.LoginDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.request.MerchantLoginRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.RequestType;
import com.epay.merchant.validator.MerchantLoginValidator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class LoginServiceTest {

    @InjectMocks
    private LoginService loginService;

    @Mock
    private MerchantLoginValidator merchantLoginValidator;

    @Mock
    private TokenService tokenService;

    @Mock
    private LoginDao loginDao;

    private MerchantLoginRequest request;

    @BeforeEach
    void setUp() {
        request = new MerchantLoginRequest();
        request.setUserName("testUser");
        request.setRequestId("12345");
    }

    @Test
    void testMerchantLogin_SuccessfulLogin() {
        // Mock successful validation and DAO calls
        doNothing().when(merchantLoginValidator).validateMerchantLoginRequest(request);
        doNothing().when(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(true), anyString());
        doNothing().when(loginDao).updateCaptchaIsVerified("12345");

        MerchantResponse<Object> response = loginService.merchantLogin(request);

        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        assertNotNull(response.getData());
        assertTrue(response.getData() instanceof List);
        assertEquals(1, ((List<?>) response.getData()).size());
        assertTrue(((List<?>) response.getData()).get(0).toString().contains("Logged In User Found"));

        verify(merchantLoginValidator).validateMerchantLoginRequest(request);
        verify(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(true), anyString());
        verify(loginDao).updateCaptchaIsVerified("12345");
    }

    @Test
    void testMerchantLogin_ValidationException() {
        ValidationException validationException = new ValidationException(List.of(new ErrorDto(ErrorConstants.MANDATORY_ERROR_CODE, "Mandatory field missing")));
        doThrow(validationException).when(merchantLoginValidator).validateMerchantLoginRequest(request);

        assertThrows(ValidationException.class, () -> loginService.merchantLogin(request));

        verify(merchantLoginValidator).validateMerchantLoginRequest(request);
        verify(loginDao, never()).saveLoginAudit(anyString(), any(), anyBoolean(), anyString());
    }

    @Test
    void testMerchantLogin_MerchantException() {
        MerchantException merchantException = new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, "User not found");
        doThrow(merchantException).when(merchantLoginValidator).validateMerchantLoginRequest(request);

        MerchantResponse<Object> response = loginService.merchantLogin(request);

        assertEquals(MerchantConstant.RESPONSE_FAILURE, response.getStatus());
        assertNotNull(response.getErrors());
        assertEquals(1, response.getErrors().size());
        assertEquals(ErrorConstants.NOT_FOUND_ERROR_CODE, response.getErrors().get(0).getErrorCode());

        verify(merchantLoginValidator).validateMerchantLoginRequest(request);
        verify(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(false), anyString());
    }

    @Test
    void testMerchantLogin_GenericException() {
        doThrow(new RuntimeException("Unexpected error")).when(merchantLoginValidator).validateMerchantLoginRequest(request);

        MerchantResponse<Object> response = loginService.merchantLogin(request);

        assertEquals(MerchantConstant.RESPONSE_FAILURE, response.getStatus());
        assertNotNull(response.getErrors());
        assertEquals(1, response.getErrors().size());
        assertEquals(ErrorConstants.GENERIC_ERROR_CODE, response.getErrors().get(0).getErrorCode());

        verify(merchantLoginValidator).validateMerchantLoginRequest(request);
        verify(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(false), anyString());
    }

    @Test
    void testHandleLoginFailure_UserExists() {
        when(tokenService.updateMerchantUserForLogin("testUser", false)).thenReturn(3);

        MerchantResponse<Object> response = loginService.merchantLogin(request);

        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        verify(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(true), anyString());
    }

    @Test
    void testHandleLoginFailure_UserNotFound() {
        when(tokenService.updateMerchantUserForLogin("testUser", false)).thenReturn(0);

        MerchantResponse<Object> response = loginService.merchantLogin(request);

        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        verify(loginDao).saveLoginAudit(eq("testUser"), eq(RequestType.LOGIN), eq(true), anyString());
    }
}




package com.epay.merchant.service;

import com.epay.merchant.dao.LoginDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.model.request.MerchantLoginRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.RequestType;
import com.epay.merchant.validator.MerchantLoginValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import java.text.MessageFormat;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.epay.merchant.util.MerchantConstant.SUCCESS_MESSAGE;

/**
 * Class Name: LoginService
 * *
 * Description: LoginService is responsible for validating the merchant login.
 * Validate the UserName and PWD to login
 * *
 * Author: Ravi Rathore
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class LoginService {

    private final MerchantLoginValidator merchantLoginValidator;
    private final TokenService tokenService;
    private final LoginDao loginDao;
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * Validates the user based on the provided validation request.
     * @param merchantLoginRequest The login validation request containing user login details with captcha.
     * @return MerchantResponse containing success or failure details.
     */
    public MerchantResponse<Object> merchantLogin(MerchantLoginRequest merchantLoginRequest) {
        log.info("Started merchantLogin for userName: {}", merchantLoginRequest.getUserName());
        try {
            log.info("validating Merchant login request for userName : {}", merchantLoginRequest.getUserName());
            merchantLoginValidator.validateMerchantLoginRequest(merchantLoginRequest);
            loginDao.saveLoginAudit(merchantLoginRequest.getUserName(), RequestType.LOGIN, true, MessageFormat.format(SUCCESS_MESSAGE, "Logged In User Found"));
            loginDao.updateCaptchaIsVerified(merchantLoginRequest.getRequestId());
            return MerchantResponse.builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(MessageFormat.format(MerchantConstant.SUCCESS_MESSAGE, "Logged In User Found"))).build();
        } catch (ValidationException e) {
            e.getErrorMessages().stream().filter(errorCode -> ErrorConstants.MANDATORY_ERROR_CODE.equals(errorCode.getErrorCode())).forEach(errorCode -> {
                throw e;
            });
            log.error("Login Validation Failed for userName {} with error {}", merchantLoginRequest.getUserName(), e.getErrorMessages().toString());
            return handleLoginFailure(merchantLoginRequest.getUserName(), e.getErrorMessages().stream().map(ErrorDto::toString).collect(Collectors.joining(", ")), e.getErrorMessages());
        } catch (MerchantException e) {
            log.error("MerchantException : Login Failed for userName {} ", merchantLoginRequest.getUserName());
            return handleLoginFailure(merchantLoginRequest.getUserName(), e.getErrorMessage(), List.of(ErrorDto.builder().errorCode(e.getErrorCode()).errorMessage(e.getErrorMessage()).build()));
        } catch (Exception e) {
            log.error("GenericException : Login Failed for userName {} ", merchantLoginRequest.getUserName(), e.getMessage());
            return handleLoginFailure(merchantLoginRequest.getUserName(), e.getLocalizedMessage(), List.of(ErrorDto.builder().errorCode(ErrorConstants.GENERIC_ERROR_CODE).errorMessage(e.getMessage()).build()));
        }
    }
    /**
     * Handles the login failure process, such as logging and updating failure count.
     * MerchantResponse failure and save Login Audit details
     * @param userName String
     * @param e String
     * @param errors List<ErrorDto>
     */
    private MerchantResponse<Object> handleLoginFailure(String userName, String e, List<ErrorDto> errors) {
        log.info("Started handleLoginFailure for userName: {}",userName);
        int loginFailureCount = 0;
        if (StringUtils.isNotEmpty(userName)) {
            try {
                log.info("Updating login failure count for userName: {}",userName);
                loginFailureCount = tokenService.updateMerchantUserForLogin(userName, false);
                if(loginFailureCount > 0) {
                    log.info("Saving login audit for userName: {},loginFailureCount :{}",userName,loginFailureCount);
                    loginDao.saveLoginAudit(userName, RequestType.LOGIN, false, e);
                }
            } catch (MerchantException ex) {
                log.error("MerchantException in handleLoginFailure for userName {}", userName, ex.getErrorMessage());
            } catch (Exception ex) {
                log.error("GenericException  in handleLoginFailure for userName {}", userName, ex.getMessage());
            }
        }
        if(loginFailureCount > 0) {
            log.info("Returning  response with  login failure count :{} for userName ;{}",loginFailureCount,userName);
            return MerchantResponse.builder().data(List.of(Map.of("loginFailAttempt", loginFailureCount))).status(MerchantConstant.RESPONSE_FAILURE).errors(errors).build();
        } else {
            log.info("Returning  failure response for userName ;{}",userName);
            return MerchantResponse.builder().status(MerchantConstant.RESPONSE_FAILURE).errors(errors).build();
        }
    }

}
