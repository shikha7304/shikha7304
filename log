package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.validator.AuthRequestValidator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthenticationServiceTest {

    @Mock
    private JwtService jwtService;

    @InjectMocks
    private AuthenticationService authenticationService;

    private AccessTokenRequest accessTokenRequest;
    private TransactionTokenRequest transactionTokenRequest;
    private UserTokenRequest userTokenRequest;

    @BeforeEach
    void setUp() {
        // Initialize mock requests
        accessTokenRequest = new AccessTokenRequest();
        accessTokenRequest.setApiKey("testApiKey");
        accessTokenRequest.setSecretKey("testSecretKey");
        accessTokenRequest.setUsername("testUser");
        accessTokenRequest.setExpirationTime(System.currentTimeMillis() + 60000);

        transactionTokenRequest = new TransactionTokenRequest();
        transactionTokenRequest.setSbiOrderReferenceNumber("12345");
        transactionTokenRequest.setMId("MID001");
        transactionTokenRequest.setUsername("testUser");
        transactionTokenRequest.setExpirationTime(System.currentTimeMillis() + 60000);

        userTokenRequest = new UserTokenRequest();
        userTokenRequest.setUsername("testUser");
        userTokenRequest.setPassword("testPassword");
        userTokenRequest.setExpirationTime(System.currentTimeMillis() + 60000);
    }

    @Test
    void generateAccessToken_ValidRequest_ReturnsToken() {
        String expectedToken = "mockAccessToken";
        
        // Mock JwtService response
        when(jwtService.generateAccessToken(any(AccessTokenRequest.class))).thenReturn(expectedToken);

        // Call the method
        String actualToken = authenticationService.generateAccessToken(accessTokenRequest);

        // Verify interactions and assertions
        assertEquals(expectedToken, actualToken);
        verify(jwtService, times(1)).generateAccessToken(accessTokenRequest);
    }

    @Test
    void generateTransactionToken_ValidRequest_ReturnsToken() {
        String expectedToken = "mockTransactionToken";

        // Mock JwtService response
        when(jwtService.generateTransactionToken(any(TransactionTokenRequest.class))).thenReturn(expectedToken);

        // Call the method
        String actualToken = authenticationService.generateTransactionToken(transactionTokenRequest);

        // Verify interactions and assertions
        assertEquals(expectedToken, actualToken);
        verify(jwtService, times(1)).generateTransactionToken(transactionTokenRequest);
    }

    @Test
    void generateUserToken_ValidRequest_ReturnsToken() {
        String expectedToken = "mockUserToken";

        // Mock JwtService response
        when(jwtService.generateUserLoginToken(any(UserTokenRequest.class))).thenReturn(expectedToken);

        // Call the method
        String actualToken = authenticationService.generateUserToken(userTokenRequest);

        // Verify interactions and assertions
        assertEquals(expectedToken, actualToken);
        verify(jwtService, times(1)).generateUserLoginToken(userTokenRequest);
    }

    @Test
    void generateAccessToken_InvalidRequest_ThrowsException() {
        AccessTokenRequest invalidRequest = new AccessTokenRequest(); // Missing required fields
        
        Exception exception = assertThrows(RuntimeException.class, () -> {
            authenticationService.generateAccessToken(invalidRequest);
        });

        assertNotNull(exception.getMessage());
    }

    @Test
    void generateTransactionToken_InvalidRequest_ThrowsException() {
        TransactionTokenRequest invalidRequest = new TransactionTokenRequest(); // Missing required fields
        
        Exception exception = assertThrows(RuntimeException.class, () -> {
            authenticationService.generateTransactionToken(invalidRequest);
        });

        assertNotNull(exception.getMessage());
    }

    @Test
    void generateUserToken_InvalidRequest_ThrowsException() {
        UserTokenRequest invalidRequest = new UserTokenRequest(); // Missing required fields
        
        Exception exception = assertThrows(RuntimeException.class, () -> {
            authenticationService.generateUserToken(invalidRequest);
        });

        assertNotNull(exception.getMessage());
    }
}




package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.validator.AuthRequestValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

/**
 * Class Name: AuthServiceImpl
 * *
 * Description: This class implements AuthenticationService interface and it's methods for implementing services.
 * *
 * Author: V1018217(Nirvay K. Bikram)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class AuthenticationService {
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(AuthenticationService.class);
    private final JwtService jwtService;

    /**
     * Generates an access token based on the provided request.
     *
     * @param accessTokenRequest AccessTokenRequest
     * @return JWT token in string form.
     */
    public String generateAccessToken(AccessTokenRequest accessTokenRequest) {
        logger.debug("Initiate generateAccessToken for {}", accessTokenRequest);
        AuthRequestValidator.validAuthRequest(accessTokenRequest);
        return jwtService.generateAccessToken(accessTokenRequest);
    }

    /**
     * Generates a transaction token based on the provided request.
     *
     * @param transactionTokenRequest TransactionTokenRequest
     * @return JWT token in string form.
     */
    public String generateTransactionToken(TransactionTokenRequest transactionTokenRequest) {
        logger.debug("Initiate generateTransactionToken for {}", transactionTokenRequest);
        AuthRequestValidator.validAuthRequest(transactionTokenRequest);
        return jwtService.generateTransactionToken(transactionTokenRequest);
    }

    /**
     * Generates a merchant user token based on the provided request.
     *
     * @param userTokenRequest UserTokenRequest
     * @return JWT token in string form.
     */
    public String generateUserToken(UserTokenRequest userTokenRequest) {
        logger.debug("Initiate generateUserToken for {}", userTokenRequest);
        AuthRequestValidator.validAuthRequest(userTokenRequest);
        return jwtService.generateUserLoginToken(userTokenRequest);
    }

}
package com.sbi.epay.authentication.validator;

import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import com.sbi.epay.authentication.dto.ErrorDto;
import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.*;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import org.apache.commons.lang3.StringUtils;
import org.springframework.util.CollectionUtils;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;


/**
 * Class Name: AuthRequestValidator
 * *
 * Description: This class contains authentication request validator and checks null/empty of request variable.
 * *
 * Author: V1018217(Nirvay K. Bikram)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
public class AuthRequestValidator {
    public static final String TOKEN_TYPE = "Token Type";
    public static final String EXPIRY_TIME = "Expiry Time";
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(AuthRequestValidator.class);

    /**
     * Validate authentication respective request object based on token type.
     *
     * @param tokenRequest gets request for validation.
     */
    public static void validAuthRequest(TokenRequest tokenRequest) {
        List<ErrorDto> errorDtoList = new ArrayList<>();
        switch (tokenRequest.getTokenType()) {
            case ACCESS -> validAccessTokenRequest((AccessTokenRequest) tokenRequest, errorDtoList);
            case TRANSACTION -> validTransactionTokenRequest((TransactionTokenRequest) tokenRequest, errorDtoList);
            case USER -> validUserTokenRequest((UserTokenRequest) tokenRequest, errorDtoList);
            default ->
                    errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.INVALID_ERROR_MESSAGE, TOKEN_TYPE)));
        }

        if (!CollectionUtils.isEmpty(errorDtoList)) {
            logger.error("Error -> ", errorDtoList);
            throw new EPaySecurityException(errorDtoList);
        }
    }

    /**
     * Validate Customer authentication request object.
     *
     * @param tokenRequest gets request related to Customer.
     * @param errorDtoList handles error/errorList while validations.
     */
    private static void validAccessTokenRequest(AccessTokenRequest tokenRequest, List<ErrorDto> errorDtoList) {
        if (StringUtils.isEmpty(tokenRequest.getApiKey())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "apiKey")));
        } else if (StringUtils.isEmpty(tokenRequest.getSecretKey())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "secretKey")));
        } else if (tokenRequest.getExpirationTime() <= System.currentTimeMillis()) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.INVALID_ERROR_MESSAGE, EXPIRY_TIME)));
        }
    }

    /**
     * Validate Transaction authentication request object.
     *
     * @param tokenRequest gets request related to transaction.
     * @param errorDtoList handles error/errorList while validations.
     */
    private static void validTransactionTokenRequest(TransactionTokenRequest tokenRequest, List<ErrorDto> errorDtoList) {
        if (StringUtils.isEmpty(tokenRequest.getSbiOrderReferenceNumber())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "orderNumber")));
        } else if (StringUtils.isEmpty(tokenRequest.getMId())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "merchant Id")));
        } else if (tokenRequest.getExpirationTime() <= System.currentTimeMillis()) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.INVALID_ERROR_MESSAGE, EXPIRY_TIME)));
        }
    }

    /**
     * Validate Merchant authentication request object.
     *
     * @param userTokenRequest gets request related to merchant.
     * @param errorDtoList         handles error/errorList while validations.
     */
    private static void validUserTokenRequest(UserTokenRequest userTokenRequest, List<ErrorDto> errorDtoList) {
        if (StringUtils.isEmpty(userTokenRequest.getUsername())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "loginName")));
        } else if (StringUtils.isEmpty(userTokenRequest.getPassword())) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.MANDATORY_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.MANDATORY_ERROR_MESSAGE, "loginPassword")));
        } else if (userTokenRequest.getExpirationTime() <= System.currentTimeMillis()) {
            errorDtoList.add(new ErrorDto(EPayAuthenticationErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.INVALID_ERROR_MESSAGE, EXPIRY_TIME)));
        }
    }

}
package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.util.EPayAuthenticationConstant;
import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.text.MessageFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import static com.sbi.epay.authentication.util.EPayJwtClaimsSet.*;

/**
 * Class Name: JwtService
 * *
 * Description: Service Class for generating and validating JSON Web Tokens (JWT).
 * * This class provides methods to create signed JWTs using various inputs, including username/pwd, API keys, and hashed values.
 * *
 * Author: V1018217(Nirvay K. Bikram)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class JwtService {
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(JwtService.class);

    private final AuthenticationUserService authenticationUserService;
    @Value("${security.jwt.secret.key}")
    private String secretKey;
    @Value("${security.jwt.secret.issuer}")
    private String issuer;

    /**
     * Generates a JWT token with the specified claims, username, and expiration time.
     *
     * @param claims         A map of claims to include in the token.
     * @param userName       The username used to sign the token.
     * @param expirationTime The expiration time of the token in milliseconds.
     * @return A signed JWT token as a string.
     */
    private String generateToken(Map<String, Object> claims, String userName, long expirationTime) {
        logger.info("ClassName - JwtService,MethodName - generateToken,generate a JWT token  with the specified claims, username, and expiration time.");
        Claims jwtClaims = Jwts.claims(claims);
        jwtClaims.setSubject(userName);
        jwtClaims.setIssuer(issuer);
        jwtClaims.setIssuedAt(new Date(System.currentTimeMillis()));
        jwtClaims.setExpiration(new Date(expirationTime));
        return Jwts.builder().setClaims(jwtClaims).signWith(getSignKey(), SignatureAlgorithm.HS512).compact();
    }

    /**
     * Generates a JWT token using a username, expirationTime and role.
     *
     * @param userTokenRequest UserTokenRequest
     * @return A signed JWT token as a string.
     */
    public String generateUserLoginToken(UserTokenRequest userTokenRequest) {
        logger.info("ClassName - JwtService,MethodName - generateTokenWithUsernamePwd, Generates a JWT token using a username, expirationTime and role.");
        Map<String, Object> claims = new HashMap<>();
        claims.put(USERNAME, userTokenRequest.getUsername());
        claims.put(ROLE, userTokenRequest.getRoles());
        claims.put(TYPE, userTokenRequest.getTokenType());
        return generateToken(claims, userTokenRequest.getUsername(), userTokenRequest.getExpirationTime());
    }

    /**
     * GenerateAccessToken method generateAccessToken and takes accessTokenRequest as parameter.
     *
     * @param accessTokenRequest AccessTokenRequest
     * @return A signed JWT token as a string.
     */
    public String generateAccessToken(AccessTokenRequest accessTokenRequest) {
        Map<String, Object> claims = new HashMap<>();
        claims.put(USERNAME, accessTokenRequest.getUsername());
        claims.put(MID, accessTokenRequest.getMId());
        claims.put(ROLE, accessTokenRequest.getRoles());
        claims.put(TYPE, accessTokenRequest.getTokenType());
        return generateToken(claims, accessTokenRequest.getUsername(), accessTokenRequest.getExpirationTime());
    }

    /**
     * Generates a JWT token using a hash of the order reference number, expiration time and merchant ID.
     *
     * @param transactionTokenRequest TransactionTokenRequest
     * @return A signed JWT token as a string.
     */
    public String generateTransactionToken(TransactionTokenRequest transactionTokenRequest) {
        logger.info("ClassName - JwtService,MethodName - generateTokenWithHash, Generates a JWT token using a hash of the order reference number, expiration time and merchant ID.");
        Map<String, Object> claims = new HashMap<>();
        claims.put(ORDER_NUMBER, transactionTokenRequest.getSbiOrderReferenceNumber());
        claims.put(MID, transactionTokenRequest.getMId());
        claims.put(USERNAME, transactionTokenRequest.getSbiOrderReferenceNumber());
        claims.put(ROLE, transactionTokenRequest.getRoles());
        claims.put(TYPE, transactionTokenRequest.getTokenType());
        claims.put(REFERENCE_ID, transactionTokenRequest.getReferenceId());
        return generateToken(claims, transactionTokenRequest.getUsername(), transactionTokenRequest.getExpirationTime());
    }

    public Claims verifyJwtTokenAndGetClaims(String token) {
        Claims claims = getAllClaimsFromToken(token);
        if (issuer.equalsIgnoreCase(claims.getIssuer())) {
            if (isTokenExpired(claims.getExpiration())) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.TOKEN_EXPIRED);
            } else if (authenticationUserService.isTokenInValid(token, claims.get(TYPE, String.class))) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_TOKEN);
            }
            String userName = (String) claims.get(USERNAME);
            String userNameWithTokenType = String.join(EPayAuthenticationConstant.JOINER, (String) claims.get(USERNAME), claims.get(TYPE, String.class));
            logger.info("Token request received for userNameWithTokenType: {}", userNameWithTokenType);
            EPayPrincipal ePayPrincipal = authenticationUserService.loadUserByUserName(userNameWithTokenType).orElseThrow(() -> new EPaySecurityException(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_MESSAGE, EPayAuthenticationErrorConstants.USER_NAME)));
            logger.info("Token request received for userNameWithTokenType: {}", userNameWithTokenType);
            if (!ePayPrincipal.getAuthenticationId().equalsIgnoreCase(userName)) {
                throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_USER);
            }
        } else {
            throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_ISSUER);
        }
        return claims;
    }


    /**
     * Get all claims from token. and @Param token
     *
     * @param token as a String
     * @return Claims of the token
     */
    private Claims getAllClaimsFromToken(String token) {
        try {
            logger.info("ClassName - JwtService,MethodName - getAllClaimsFromToken, getting all claims from token.");
            return Jwts.parserBuilder().setSigningKey(getSignKey()).build().parseClaimsJws(token).getBody();
        } catch (ExpiredJwtException e) {
            logger.error("Jwt Token is expired : {}", e.getLocalizedMessage());
            throw new IllegalStateException(EPayAuthenticationErrorConstants.TOKEN_EXPIRED);
        }  catch (SignatureException e) {
            logger.error("Jwt Token is expired : {}", e.getLocalizedMessage());
            throw new IllegalStateException(EPayAuthenticationErrorConstants.INVALID_TOKEN);
       }

    }

    /**
     * Get SigningKey
     *
     * @return signed key
     */
    private Key getSignKey() {
        logger.info("ClassName - JwtService,MethodName - getSignKey, getting SigningKey.");
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * Get expiration time from token
     *
     * @param expiration is as Date
     * @return Boolean true if token is expired otherwise false.
     */
    private Boolean isTokenExpired(Date expiration) {
        logger.info("ClassName - JwtService,MethodName - isTokenExpired, getting expiration time from token.");
        return expiration.before(new Date());
    }

}
