

public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantUserValidator merchantUserValidator;
    private final MerchantMapper merchantMapper;

    private final Logger log = LoggerFactory.getLogger(MerchantUserService.class);

    public MerchantResponse<MerchantInfoResponse> getAllAccessMerchantInfo(Pageable pageable) {
        log.info("Fetching all accessible merchant info for the logged-in user");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        log.debug("UserName: {}", userName);

        Page<MerchantInfoDto> merchantInfo = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName, pageable);
        log.debug("Fetched {} merchant info records for user {}", merchantInfo.getTotalElements(), userName);

        List<MerchantInfoResponse> merchantInfoResponseList = merchantMapper.mapMerchantInfoDTOListToResponseList(merchantInfo.getContent());
        log.info("Successfully mapped merchant info to response");

        return MerchantResponse.<MerchantInfoResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(merchantInfoResponseList)
                .count(merchantInfo.stream().count())
                .total(merchantInfo.getTotalElements())
                .build();
    }

    public MerchantResponse<MerchantUserAccessResponse> getMerchantUserAccess() {
        log.info("Fetching merchant user access for the logged-in user");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        log.debug("UserName: {}", userName);

        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        if (ObjectUtils.isEmpty(merchantUserDto)) {
            log.error("No active merchant user found for username: {}", userName);
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE,
                    MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName"));
        }

        log.debug("Merchant user details fetched for username: {}", userName);

        List<UserMenuPermissionEntityResponse> userAccess = merchantUserDao.getUserMenuPermission(merchantUserDto.getId());
        log.debug("Fetched {} menu permissions for user ID: {}", userAccess.size(), merchantUserDto.getId());

        MerchantUserAccessResponse merchantUserAccessResponse = MerchantUserAccessResponse.builder()
                .userInfo(merchantUserDto)
                .userAccess(userAccess)
                .build();

        log.info("Successfully fetched merchant user access for {}", userName);

        return MerchantResponse.<MerchantUserAccessResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(List.of(merchantUserAccessResponse))
                .build();
    }

    public MerchantResponse<UserProfileResponse> getMerchantUserProfile() {
        log.info("Fetching profile for the logged-in user");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        log.debug("UserName: {}", userName);

        UserProfileResponse userProfileResponse = merchantUserDao.getMerchantUserProfile(userName, UserStatus.ACTIVE);
        if (userProfileResponse == null) {
            log.error("No user profile found for username: {}", userName);
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE,
                    MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserProfile"));
        }

        log.info("Successfully fetched user profile for {}", userName);

        return MerchantResponse.<UserProfileResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(List.of(userProfileResponse))
                .count(1L)
                .total(1L)
                .build();
    }

    public MerchantResponse<MerchantUserResponse> createMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Creating a new merchant user");
        log.debug("MerchantUserRequest: {}", merchantUserRequest);

        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, true);
        log.info("Merchant user request validation passed");

        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, false, false);
        log.info("Merchant user created successfully with username: {}", merchantUserRequest.getUserName());

        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Updating merchant user details for username: {}", merchantUserRequest.getUserName());
        log.debug("MerchantUserRequest: {}", merchantUserRequest);

        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, false);
        log.info("Merchant user request validation passed");

        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, false, true);
        log.info("Merchant user updated successfully for username: {}", merchantUserRequest.getUserName());

        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUserProfile(MerchantUserRequest merchantUserRequest) {
        log.info("Updating profile for merchant user: {}", merchantUserRequest.getUserName());
        log.debug("MerchantUserRequest: {}", merchantUserRequest);

        merchantUserValidator.validateMerchantUserProfile(merchantUserRequest);
        log.info("Merchant user profile validation passed");

        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, true, true);
        log.info("Merchant user profile updated successfully for username: {}", merchantUserRequest.getUserName());

        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateUserStatus(MerchantUserStatusRequest merchantUserStatusRequest) {
        log.info("Updating status for user: {}", merchantUserStatusRequest.getUserName());
        log.debug("MerchantUserStatusRequest: {}", merchantUserStatusRequest);

        merchantUserValidator.validateUpdateUserStatus(merchantUserStatusRequest);
        log.info("Merchant user status validation passed");

        MerchantUserResponse merchantUserResponse = merchantUserDao.updateUserStatusByUserName(
                merchantUserStatusRequest.getUserName(),
                merchantUserStatusRequest.getUserStatus(),
                merchantUserStatusRequest.getRemark()
        );

        log.info("User status updated successfully for username: {}", merchantUserStatusRequest.getUserName());

        return MerchantResponse.<MerchantUserResponse>builder()
                .data(List.of(merchantUserResponse))
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count(1L)
                .total(1L)
                .build();
    }

    private MerchantResponse<MerchantUserResponse> saveMerchantUser(MerchantUserRequest merchantUserRequest, boolean isProfileUpdate, boolean isUpdate) {
        log.info("{} merchant user with username: {}", isUpdate ? "Updating" : "Creating", merchantUserRequest.getUserName());
        log.debug("MerchantUserRequest: {}", merchantUserRequest);

        MerchantUserDto merchantUserDto = merchantMapper.mapMerchantUserRequestToMerchantUserDto(merchantUserRequest);

        if (isUpdate) {
            merchantUserDto = merchantUserDao.updateMerchantUser(merchantUserDto, isProfileUpdate);
            log.info("Merchant user updated in the database for username: {}", merchantUserRequest.getUserName());
        } else {
            merchantUserDto = merchantUserDao.saveMerchantUser(merchantUserDto, StringUtils.EMPTY);
            log.info("Merchant user saved in the database for username: {}", merchantUserRequest.getUserName());
        }

        MerchantUserResponse merchantUserResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        log.debug("MerchantUserResponse: {}", merchantUserResponse);

        merchantUserResponse.setRoleName(merchantUserDao.getUserRoleName(merchantUserDto.getRole()));
        log.info("Merchant user role resolved for username: {}", merchantUserRequest.getUserName());

        return MerchantResponse.<MerchantUserResponse>builder()
                .data(List.of(merchantUserResponse))
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count(1L)
                .build();
    }

    public MerchantResponse<UserRoleResponse> getUserRole() {
        log.info("Fetching all user roles");
        List<UserRoleResponse> userRoleResponse = merchantUserDao.getUserRoles();
        log.debug("Fetched {} user roles", userRoleResponse.size());

        log.info("Successfully fetched user roles");
        return MerchantResponse.<UserRoleResponse>builder()
                .data(userRoleResponse)
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count((long) userRoleResponse.size())
                .build();
    }
}







public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantUserValidator merchantUserValidator;
    private final MerchantMapper merchantMapper;

    private final Logger log = LoggerFactory.getLogger(MerchantUserService.class);

    // Static utility methods remain unchanged

    public MerchantResponse<MerchantInfoResponse> getAllAccessMerchantInfo(Pageable pageable) {
        log.info("Start: getAllAccessMerchantInfo");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        Page<MerchantInfoDto> merchantInfo = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName, pageable);
        List<MerchantInfoResponse> merchantInfoResponseList = merchantMapper.mapMerchantInfoDTOListToResponseList(merchantInfo.getContent());
        log.info("End: getAllAccessMerchantInfo");
        return MerchantResponse.<MerchantInfoResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(merchantInfoResponseList)
                .count(merchantInfo.stream().count())
                .total(merchantInfo.getTotalElements())
                .build();
    }

    public MerchantResponse<MerchantUserAccessResponse> getMerchantUserAccess() {
        log.info("Start: getMerchantUserAccess");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        merchantUserDto.setRoleName(merchantUserDao.getRoleNameByRoleId(merchantUserDto.getRole()));
        if (ObjectUtils.isEmpty(merchantUserDto)) {
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, 
                    MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName"));
        }
        List<UserMenuPermissionEntityResponse> userAccess = merchantUserDao.getUserMenuPermission(merchantUserDto.getId());
        MerchantUserAccessResponse merchantUserAccessResponse = MerchantUserAccessResponse.builder()
                .userInfo(merchantUserDto)
                .userAccess(userAccess)
                .build();
        log.info("End: getMerchantUserAccess");
        return MerchantResponse.<MerchantUserAccessResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(List.of(merchantUserAccessResponse))
                .build();
    }

    public MerchantResponse<UserProfileResponse> getMerchantUserProfile() {
        log.info("Start: getMerchantUserProfile");
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();
        UserProfileResponse userProfileResponse = merchantUserDao.getMerchantUserProfile(userName, UserStatus.ACTIVE);
        log.info("End: getMerchantUserProfile");
        return MerchantResponse.<UserProfileResponse>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(List.of(userProfileResponse))
                .count(1L)
                .total(1L)
                .build();
    }

    public MerchantResponse<MerchantUserResponse> createMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Start: createMerchantUser");
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, true);
        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, false, false);
        log.info("End: createMerchantUser");
        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUser(MerchantUserRequest merchantUserRequest) {
        log.info("Start: updateMerchantUser");
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, false);
        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, false, true);
        log.info("End: updateMerchantUser");
        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUserProfile(MerchantUserRequest merchantUserRequest) {
        log.info("Start: updateMerchantUserProfile");
        merchantUserValidator.validateMerchantUserProfile(merchantUserRequest);
        MerchantResponse<MerchantUserResponse> response = saveMerchantUser(merchantUserRequest, true, true);
        log.info("End: updateMerchantUserProfile");
        return response;
    }

    public MerchantResponse<MerchantUserResponse> updateUserStatus(MerchantUserStatusRequest merchantUserStatusRequest) {
        log.info("Start: updateUserStatus");
        merchantUserValidator.validateUpdateUserStatus(merchantUserStatusRequest);
        MerchantUserResponse merchantUserResponse = merchantUserDao.updateUserStatusByUserName(
                merchantUserStatusRequest.getUserName(),
                merchantUserStatusRequest.getUserStatus(),
                merchantUserStatusRequest.getRemark()
        );
        log.info("End: updateUserStatus");
        return MerchantResponse.<MerchantUserResponse>builder()
                .data(List.of(merchantUserResponse))
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count(1L)
                .total(1L)
                .build();
    }

    private MerchantResponse<MerchantUserResponse> saveMerchantUser(MerchantUserRequest merchantUserRequest, boolean isProfileUpdate, boolean isUpdate) {
        log.info("Start: saveMerchantUser");
        MerchantUserDto merchantUserDto = merchantMapper.mapMerchantUserRequestToMerchantUserDto(merchantUserRequest);
        if (isUpdate) {
            merchantUserDto = merchantUserDao.updateMerchantUser(merchantUserDto, isProfileUpdate);
        } else {
            merchantUserDto = merchantUserDao.saveMerchantUser(merchantUserDto, StringUtils.EMPTY);
        }
        MerchantUserResponse merchantUserResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        merchantUserResponse.setRoleName(merchantUserDao.getUserRoleName(merchantUserDto.getRole()));
        log.info("End: saveMerchantUser");
        return MerchantResponse.<MerchantUserResponse>builder()
                .data(List.of(merchantUserResponse))
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count(1L)
                .build();
    }

    public MerchantResponse<UserRoleResponse> getUserRole() {
        log.info("Start: getUserRole");
        List<UserRoleResponse> userRoleResponse = merchantUserDao.getUserRoles();
        log.info("End: getUserRole");
        return MerchantResponse.<UserRoleResponse>builder()
                .data(userRoleResponse)
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .count((long) userRoleResponse.size())
                .build();
    }

    // Similar logging patterns can be added for the remaining methods

}







public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantUserValidator merchantUserValidator;
    private final MerchantMapper merchantMapper;

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private static List<String> getNewMenuMappingList(List<String> menuList, List<UserMenuPermissionEntityResponse> assignedMenus) {
        List<String> newMappedMenu = new ArrayList<>();
        for (String menu : menuList){
            boolean mIdFound = false;
            for (UserMenuPermissionEntityResponse assignedMenu : assignedMenus) {
                if (menu.equalsIgnoreCase(assignedMenu.getMenuCode())) {
                   mIdFound = true;
                    break;
                }
            }
            if(!mIdFound){
                newMappedMenu.add(menu);
            }
        }
        return newMappedMenu;
    }

    private static List<String> getNewMIdMappingList(List<String> mIds, List<MerchantInfoDto> assignedMIds) {
        List<String> newMappedMIds = new ArrayList<>();
        for (String mId : mIds) {
            boolean mIdFound = false;
            for (MerchantInfoDto assignedMId : assignedMIds) {
                if (mId.equalsIgnoreCase(assignedMId.getMId())) {
                    mIdFound = true;
                    break;
                }
            }
            if (!mIdFound) {
                newMappedMIds.add(mId);
            }
        }
        return newMappedMIds;
    }

    /**
     * Fetches all merchant information accessible to the logged-in user with pagination support.
     *
     * @param pageable Pageable object for pagination details.
     * @return MerchantResponse containing a paginated list of merchant information.
     */
    public MerchantResponse<MerchantInfoResponse> getAllAccessMerchantInfo(Pageable pageable) {
        log.info("Fetching all merchant information");

        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get All Merchant Info which is accessible to Logged in Merchant User
        Page<MerchantInfoDto> merchantInfo = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName, pageable);

        // Step 3 : Covert DTO to Response Object
        List<MerchantInfoResponse> merchantInfoResponseList = merchantMapper.mapMerchantInfoDTOListToResponseList(merchantInfo.getContent());

        // Step 4 : Building the response
        return MerchantResponse.<MerchantInfoResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(merchantInfoResponseList).count(merchantInfo.stream().count()).total(merchantInfo.getTotalElements()).build();
    }

    /**
     * Retrieves the logged-in user's basic information and access details,
     * including menu permissions and roles.
     *
     * @return MerchantResponse containing the user's access details.
     */
    public MerchantResponse<MerchantUserAccessResponse> getMerchantUserAccess() {
        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
        merchantUserDto.setRoleName(merchantUserDao.getRoleNameByRoleId(merchantUserDto.getRole()));
        if (ObjectUtils.isEmpty(merchantUserDto)) {
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName"));
        }

        // Step 3 : Get Merchant Permission Info of Logged in Merchant User
        List<UserMenuPermissionEntityResponse> userAccess = merchantUserDao.getUserMenuPermission(merchantUserDto.getId());

        // Step 4 : Build Merchant User Access Response
        MerchantUserAccessResponse merchantUserAccessResponse = MerchantUserAccessResponse.builder().userInfo(merchantUserDto).userAccess(userAccess).build();

        // Step 4 : Building the response
        return MerchantResponse.<MerchantUserAccessResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(merchantUserAccessResponse)).build();
    }

    /**
     * Fetches the profile details of the logged-in merchant user.
     *
     * @return MerchantResponse containing the user's profile information.
     */
    public MerchantResponse<UserProfileResponse> getMerchantUserProfile() {

        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        UserProfileResponse userProfileResponse = merchantUserDao.getMerchantUserProfile(userName, UserStatus.ACTIVE);

        // Step 3 : Building the response
        return MerchantResponse.<UserProfileResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(userProfileResponse)).count(1L).total(1L).build();
    }

    /**
     * Creates a new merchant user based on the provided request details.
     * Validates the request before saving the user data.
     *
     * @param merchantUserRequest Request object containing merchant user details.
     * @return MerchantResponse containing the created user's details.
     */
    public MerchantResponse<MerchantUserResponse> createMerchantUser(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, true);
        return saveMerchantUser(merchantUserRequest, false, false);
    }

    /**
     * Updates an existing merchant user's details based on the provided request.
     * Validates the request before updating the user data.
     *
     * @param merchantUserRequest Request object containing updated user details.
     * @return MerchantResponse containing the updated user's details.
     */
    public MerchantResponse<MerchantUserResponse> updateMerchantUser(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, false);
        return saveMerchantUser(merchantUserRequest, false, true);
    }

    /**
     * Updates the profile of the logged-in merchant user.
     * Validates the request before performing the update.
     *
     * @param merchantUserRequest Request object containing profile details.
     * @return MerchantResponse containing the updated profile information.
     */
    public MerchantResponse<MerchantUserResponse> updateMerchantUserProfile(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserProfile(merchantUserRequest);
        return saveMerchantUser(merchantUserRequest, true, true);
    }

    /**
     * Update Merchant User Status
     *
     * @param merchantUserStatusRequest MerchantUserStatusRequest
     * @return MerchantResponse<MerchantUserResponse> - Response containing updated user information
     */
    public MerchantResponse<MerchantUserResponse> updateUserStatus(MerchantUserStatusRequest merchantUserStatusRequest) {
        log.info("Updating status Request {}", merchantUserStatusRequest);
        merchantUserValidator.validateUpdateUserStatus(merchantUserStatusRequest);
        MerchantUserResponse merchantUserResponse = merchantUserDao.updateUserStatusByUserName(merchantUserStatusRequest.getUserName(), merchantUserStatusRequest.getUserStatus(), merchantUserStatusRequest.getRemark());
        return MerchantResponse.<MerchantUserResponse>builder().data(List.of(merchantUserResponse)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).total(1L).build();
    }

    /**
     * Saves the merchant user details to the database.
     * Handles both new user creation and user updates.
     *
     * @param merchantUserRequest Request object containing user details.
     * @param isProfileUpdate     Indicates if the update is specific to a profile.
     * @param isUpdate            Indicates if the operation is an update.
     * @return MerchantResponse containing the saved user's details.
     */
    private MerchantResponse<MerchantUserResponse> saveMerchantUser(MerchantUserRequest merchantUserRequest, boolean isProfileUpdate, boolean isUpdate) {
        //Step 1 : Save the Merchant User Data in DB
        MerchantUserDto merchantUserDto = merchantMapper.mapMerchantUserRequestToMerchantUserDto(merchantUserRequest);
        if (isUpdate) {
            merchantUserDto = merchantUserDao.updateMerchantUser(merchantUserDto, isProfileUpdate);
        } else {
            merchantUserDto = merchantUserDao.saveMerchantUser(merchantUserDto, StringUtils.EMPTY);
        }
        //Step 2 : Build MerchantResponse and return to caller
        MerchantUserResponse merchantUserResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        merchantUserResponse.setRoleName(merchantUserDao.getUserRoleName(merchantUserDto.getRole()));
        return MerchantResponse.<MerchantUserResponse>builder().data(List.of(merchantUserResponse)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).build();
    }

    /**
     * Searches for merchant users based on the provided search criteria.
     * Returns a paginated list of matching merchant users.
     *
     * @param merchantUserGetRequest Request object containing search criteria.
     * @return MerchantResponse containing the search results.
     */
    public MerchantResponse<MerchantUserResponse> searchMerchantUsers(MerchantUserGetRequest merchantUserGetRequest) {
        Page<MerchantUserDto> merchantUsers = merchantUserDao.findMerchantUsers(merchantUserGetRequest);
        List<MerchantUserResponse> merchantUserResponseList = merchantMapper.mapMerchantUserDTOListToResponseList(merchantUsers.getContent());
        return MerchantResponse.<MerchantUserResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(merchantUserResponseList).count(merchantUsers.stream().count()).total(merchantUsers.getTotalElements()).build();
    }

    /**
     * Fetches all user roles available in the system.
     *
     * @return MerchantResponse containing a list of user roles.
     */
    public MerchantResponse<UserRoleResponse> getUserRole() {
        log.info("Started fetching user roles");
        List<UserRoleResponse> userRoleResponse = merchantUserDao.getUserRoles();
        return MerchantResponse.<UserRoleResponse>builder().data(userRoleResponse).status(MerchantConstant.RESPONSE_SUCCESS).count((long) userRoleResponse.size()).build();
    }

    /**
     * Retrieves the assigned and unassigned MIDs of a specified user.
     * Validates if the logged-in user is authorized to perform this operation.
     *
     * @param userName Username of the merchant user.
     * @return MerchantResponse containing lists of assigned and unassigned MIDs.
     */
    public MerchantResponse<MerchantUserAssignedMIdsResponse> getAssignedUnAssignedMIdsOfUser(String userName) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatedMappingRequest(userName, merchantUser);

        //Step 3  : Get Assigned MIds
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);

        //Step 4  : Get UnAssigned MIds from ParentUser
        List<MerchantInfoResponse> unAssignedMerchantInfo = getParentAssignedMIds(merchantUser, assignedMIds);

        //Step 5  : Build MerchantUserAssignedMIdsResponse
        List<MerchantInfoResponse> assignedMerchantInfo = merchantMapper.mapMerchantInfoDTOListToResponseList(assignedMIds);
        MerchantUserAssignedMIdsResponse userAssignedMIdsResponse = MerchantUserAssignedMIdsResponse.builder().assignedMIds(assignedMerchantInfo).unAssignedMIds(unAssignedMerchantInfo).build();

        //Step 6 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<MerchantUserAssignedMIdsResponse>builder().data(List.of(userAssignedMIdsResponse)).build();
    }

    /**
     * Assigns a list of MIDs to the specified user.
     * Validates the request and updates the database with the new mappings.
     *
     * @param userName Username of the merchant user.
     * @param mIds     List of MIDs to be assigned to the user.
     * @return MerchantResponse confirming the successful assignment.
     */
    public MerchantResponse<String> assignedMIdsToUser(String userName, List<String> mIds) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatePostMapping(userName, merchantUser, mIds);

        //Step 3  : Build Remove and new Assigned MIds list from current data
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);
        List<String> removedMIds = assignedMIds.stream().map(MerchantInfoDto::getMId).filter(mId -> !mIds.contains(mId)).collect(Collectors.toList());
        List<String> newMappedMIds = getNewMIdMappingList(mIds, assignedMIds);

        //Step 4 : Update the data in DB as per remove and new MIDs list
        merchantUserDao.assignedMIds(newMappedMIds, removedMIds, merchantUser.getId());

        //Step 5 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<String>builder().data(List.of("MIds is assigned Successfully")).build();
    }

    public MerchantResponse<MerchantUserAssignedMenusResponse> getAssignedUnAssignedMenuAccessOfUser(String userName) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatedMappingRequest(userName, merchantUser);

        //Step 3  : Get Assigned Menus
        List<UserMenuPermissionEntityResponse> assignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getId());

        //Step 4  : Get UnAssigned Menus from ParentUser
        List<UserMenuPermissionEntityResponse> unAssignedMenus = getParentAssignedMenus(merchantUser, assignedMenus);

        //Step 5  : Build MerchantUserAssignedMenusResponse
        MerchantUserAssignedMenusResponse userAssignedMenusResponse = MerchantUserAssignedMenusResponse.builder().assignedMenus(assignedMenus).unAssignedMenus(unAssignedMenus).build();

        //Step 6 :  Build MerchantResponse Object of MerchantUserAssignedMenusResponse
        return MerchantResponse.<MerchantUserAssignedMenusResponse>builder().data(List.of(userAssignedMenusResponse)).build();
    }

    public MerchantResponse<String> assignedMenuAccessToUser(String userName, List<String> menuList) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validateMenuPostMapping(userName, merchantUser, menuList);

        //Step 3  : Build Remove and new Assigned Menu list from current data
        List<UserMenuPermissionEntityResponse> assignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getId());
        List<UUID> removedMenus = assignedMenus.stream().filter(assignedMenu -> !menuList.contains(assignedMenu.getMenuCode())).map(UserMenuPermissionEntityResponse::getMenuId).collect(Collectors.toList());
        List<String> newMappedMenus = getNewMenuMappingList(menuList, assignedMenus);

        //Step 4 : Update the data in DB as per remove and new Menu list
        merchantUserDao.assignedMenus(newMappedMenus, removedMenus, merchantUser.getId());

        //Step 5 :  Build MerchantResponse
        return MerchantResponse.<String>builder().data(List.of("Menus is assigned Successfully")).build();
    }

    /**
     * Retrieves the unassigned MIDs for a specified user by comparing the parent's
     * accessible MIDs with the user's currently assigned MIDs.
     *
     * @param merchantUser Merchant user details.
     * @param assignedMIds List of currently assigned MIDs for the user.
     * @return List of unassigned MIDs available for the user.
     */
    private List<MerchantInfoResponse> getParentAssignedMIds(MerchantUserDto merchantUser, List<MerchantInfoDto> assignedMIds) {
        List<MerchantInfoResponse> unAssignedMerchantInfo = new ArrayList<>();

        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            //Step 2: Get Parent Assigned MIDs List
            List<MerchantInfoDto> parentAssignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(merchantUser.getParentUserId());

            //Step 3: Remove Assigned MIDs List from Parent Assigned MIDs List
            parentAssignedMIds.removeAll(assignedMIds);
            if (CollectionUtils.isNotEmpty(parentAssignedMIds)) {
                unAssignedMerchantInfo.addAll(merchantMapper.mapMerchantInfoDTOListToResponseList(parentAssignedMIds));
            }
        }
        return unAssignedMerchantInfo;
    }

    private List<UserMenuPermissionEntityResponse> getParentAssignedMenus(MerchantUserDto merchantUser, List<UserMenuPermissionEntityResponse> assignedMenus) {
        List<UserMenuPermissionEntityResponse> unAssignedMerchantInfo = new ArrayList<>();

        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            //Step 2: Get Parent Assigned MIDs List
            List<UserMenuPermissionEntityResponse> parentAssignedMenus = merchantUserDao.getUserMenuPermission(merchantUser.getParentUserId());

            //Step 3: Remove Assigned MIDs List from Parent Assigned MIDs List
            parentAssignedMenus.removeAll(assignedMenus);
            for (UserMenuPermissionEntityResponse p : parentAssignedMenus) {
                boolean isFound = false;
                for (UserMenuPermissionEntityResponse a : assignedMenus) {
                    if (a.getMenuCode().equalsIgnoreCase(p.getMenuCode())) {
                        isFound = true;
                        break;
                    }
                }
                if(!isFound) {
                    unAssignedMerchantInfo.add(p);
                }
            }
        }
        return unAssignedMerchantInfo;
    }


}
