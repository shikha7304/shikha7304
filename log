package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import com.sbi.epay.authentication.util.enums.TokenType;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.security.Key;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class JwtServiceTest {

    @InjectMocks
    private JwtService jwtService;

    @Mock
    private AuthenticationUserService authenticationUserService;

    private String secretKey;
    private String issuer;

    @BeforeEach
    void setUp() throws Exception {
        // Generate a valid secret key
        secretKey = Base64.getEncoder().encodeToString(Keys.secretKeyFor(SignatureAlgorithm.HS512).getEncoded());
        issuer = "testIssuer";

        // Use reflection to set private fields in JwtService
        java.lang.reflect.Field secretKeyField = JwtService.class.getDeclaredField("secretKey");
        secretKeyField.setAccessible(true);
        secretKeyField.set(jwtService, secretKey);

        java.lang.reflect.Field issuerField = JwtService.class.getDeclaredField("issuer");
        issuerField.setAccessible(true);
        issuerField.set(jwtService, issuer);
    }

    @Test
    void testGenerateUserLoginToken() {
        UserTokenRequest request = new UserTokenRequest();
        request.setUsername("testUser");
        request.setRoles(Collections.singletonList("ROLE_USER"));
        request.setTokenType(TokenType.USER);
        request.setPassword("password");
        request.setExpirationTime(System.currentTimeMillis() + 10000);

        String token = jwtService.generateUserLoginToken(request);
        assertNotNull(token);
        assertFalse(token.isEmpty());
    }

    @Test
    void testGenerateAccessToken() {
         AccessTokenRequest request = new AccessTokenRequest();
        request.setUsername("testUser");
        request.setMId("MID123");
        request.setPassword("password");
        request.setRoles(Collections.singletonList("ROLE_ADMIN"));
        request.setTokenType(TokenType.ACCESS);
        request.setExpirationTime(System.currentTimeMillis() + 100000);

        String token = jwtService.generateAccessToken(request);
        assertNotNull(token);
        assertFalse(token.isEmpty());
    }

    @Test
    void testGenerateTransactionToken() {
        TransactionTokenRequest request = new TransactionTokenRequest();
        request.setSbiOrderReferenceNumber("ORD123");
        request.setMId("MID123");
        request.setUsername("testUser");
        request.setRoles(Collections.singletonList("ROLE_ADMIN"));
        request.setTokenType(TokenType.TRANSACTION);
        request.setReferenceId("REF123");
        request.setExpirationTime(System.currentTimeMillis() + 10000);

        String token = jwtService.generateTransactionToken(request);
        assertNotNull(token);
    }

    @Test
    void testGenerateToken() {
        String userName = "testUser";
        long expirationTime = System.currentTimeMillis() + 10000;

        Claims jwtClaims = Jwts.claims();
        jwtClaims.setSubject(userName);
        jwtClaims.setIssuer(issuer);
        jwtClaims.setIssuedAt(new Date());
        jwtClaims.setExpiration(new Date(expirationTime));
        String token = Jwts.builder().setClaims(jwtClaims).signWith(Keys.hmacShaKeyFor(Base64.getDecoder().decode(secretKey)), SignatureAlgorithm.HS512).compact();
        assertNotNull(token);
        assertFalse(token.isEmpty());
    }
    @Test
    void testVerifyJwtTokenAndGetClaims_ValidToken() {
        Claims claims = Jwts.claims();
        claims.put("username", "testUser");
        claims.put("type", "ACCESS");
        claims.setIssuer(issuer);
        claims.setExpiration(new Date(System.currentTimeMillis() + 10000));

        String token = Jwts.builder().setClaims(claims).signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey)), SignatureAlgorithm.HS512).compact();

        EPayPrincipal ePayPrincipal = mock(EPayPrincipal.class);
        when(ePayPrincipal.getAuthenticationId()).thenReturn("testUser");

        when(authenticationUserService.isTokenInValid(token, "ACCESS")).thenReturn(false);
        when(authenticationUserService.loadUserByUserName(anyString())).thenReturn(Optional.of(ePayPrincipal));

        Claims resultClaims = jwtService.verifyJwtTokenAndGetClaims(token);

        assertNotNull(resultClaims);
        assertEquals("testUser", resultClaims.get("username"));
    }
    @Test
    void testIsTokenExpired_True() {
        assertTrue(jwtService.isTokenExpired(new Date(System.currentTimeMillis() - 10000)));
    }

    @Test
    void testIsTokenExpired_False() {
        assertFalse(jwtService.isTokenExpired(new Date(System.currentTimeMillis() + 10000)));
    }

    @Test
    void testGetAllClaimsFromToken_ExpiredToken() {
        // Mock JWT parser to throw ExpiredJwtException
        JwtParser jwtParserMock = mock(JwtParser.class);
        JwtParserBuilder jwtParserBuilderMock = mock(JwtParserBuilder.class);

        // Mock behavior of parserBuilder to return the mocked parser
        mockStatic(Jwts.class);
        when(Jwts.parserBuilder()).thenReturn(jwtParserBuilderMock);
        when(jwtParserBuilderMock.setSigningKey(any(Key.class))).thenReturn(jwtParserBuilderMock);
        when(jwtParserBuilderMock.build()).thenReturn(jwtParserMock);

        // Create a dummy JWT exception
        ExpiredJwtException expiredJwtException = new ExpiredJwtException(null, null, "Token expired");

        // Force the mock parser to throw ExpiredJwtException
        when(jwtParserMock.parseClaimsJws(anyString())).thenThrow(expiredJwtException);

        String expiredToken = "expiredToken";

        // Assert that IllegalStateException is thrown instead
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            jwtService.getAllClaimsFromToken(expiredToken);
        });

        // Validate that the re-thrown exception contains the correct error message
        assertEquals(EPayAuthenticationErrorConstants.TOKEN_EXPIRED, exception.getMessage());
    }
    @Test
    void testGetAllClaimsFromToken_InvalidSignature() {
        // Mock JWT parser to throw SignatureException
        JwtParser jwtParserMock = mock(JwtParser.class);
        JwtParserBuilder jwtParserBuilderMock = mock(JwtParserBuilder.class);

        // Mock behavior of parserBuilder to return the mocked parser
        mockStatic(Jwts.class);
        when(Jwts.parserBuilder()).thenReturn(jwtParserBuilderMock);
        when(jwtParserBuilderMock.setSigningKey(any(Key.class))).thenReturn(jwtParserBuilderMock);
        when(jwtParserBuilderMock.build()).thenReturn(jwtParserMock);

        // Force the mock parser to throw SignatureException
        when(jwtParserMock.parseClaimsJws(anyString())).thenThrow(new SignatureException("Invalid token signature"));

        String invalidToken = "invalidToken";

        // Assert that IllegalStateException is thrown instead
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            jwtService.getAllClaimsFromToken(invalidToken);
        });

        // Validate that the re-thrown exception contains the correct error message
        assertEquals(EPayAuthenticationErrorConstants.INVALID_TOKEN, exception.getMessage());
    }
}
Cannot invoke "io.jsonwebtoken.Claims.setSubject(String)" because "jwtClaims" is null
java.lang.NullPointerException: Cannot invoke "io.jsonwebtoken.Claims.setSubject(String)" because "jwtClaims" is null
	at com.sbi.epay.authentication.service.JwtService.generateToken(JwtService.java:65)
	at com.sbi.epay.authentication.service.JwtService.generateAccessToken(JwtService.java:99)
	at com.sbi.epay.authentication.service.JwtServiceTest.testGenerateAccessToken(JwtServiceTest.java:86)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)



For io.jsonwebtoken.Jwts, static mocking is already registered in the current thread

To create a new mock, the existing static mock registration must be deregistered
org.mockito.exceptions.base.MockitoException: 
For io.jsonwebtoken.Jwts, static mocking is already registered in the current thread

To create a new mock, the existing static mock registration must be deregistered
	at com.sbi.epay.authentication.service.JwtServiceTest.testGetAllClaimsFromToken_InvalidSignature(JwtServiceTest.java:186)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)


OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
