Description

For a merchant, we need to implement captcha mechanism during login, reset password functionality to prevent unauthorized access and ensure enhanced security for an application.

API Details

Method: Post

API Definition: /merchant/v1/captcha

Access Type: Open API

Request Body:



{
  "requestType": String,
  "requestId": String
}





        
      request Type need to be Enum and can hold the value - LOGIN, RESET_PASSWORD

        
      request Id need to be unique for each captcha request and need to maintain until Request complete.

        
      Both fields are mandatory


Success Response Body

{
  "data": [
    {
       "id": UUID,
       "captchaImage": BASE64,
       "expiryTime": long,
    }
   ],
  "status":1,
  "count": 1,
  "total": 1
}



Failure Response Body

{
  "status":0,
  "error": [
     {
       "errorCode": String,
       "errorMessage": String
     }
   ]
}



Testing Checklist


        
      Verify Captcha generation and image quality.

        
      Test with valid and invalid Captcha inputs.

        
      Check for edge cases like session expiration or multiple users.

        
      Ensure Captcha images are refreshed and expire as expected.

        
      Test Captcha functionality for edge cases (e.g., expiration, retries).

        
      Verify integration with the login API.


Developer Checklist

Class Flow



90% Unit test case coverage


Development Steps for Captcha Implementation 
Step 1: Add Captcha Library: com.github.penggle.kaptcha: 2.3.2 This library will be used to generate Captcha images and texts dynamically. 
Step 2: Configure Captcha Generator_ -_ Set up a Spring Bean to configure the Captcha properties. These properties include image dimensions, font size, text length, and other visual settings. 

@Configuration public class CaptchaConfig {      
@Bean     
public DefaultKaptcha captchaProducer() {         
       DefaultKaptcha captcha = new DefaultKaptcha();         
       Properties properties = new Properties();         properties.setProperty("kaptcha.border", "no");         properties.setProperty("kaptcha.textproducer.font.color", "black");         properties.setProperty("kaptcha.textproducer.char.space", "5");         properties.setProperty("kaptcha.image.width", "200");         properties.setProperty("kaptcha.image.height", "50");         properties.setProperty("kaptcha.textproducer.font.size", "40");         properties.setProperty("kaptcha.textproducer.char.length", "6");         captcha.setConfig(new Config(properties));         
       return captcha;     
} 
}  


This ensures Captcha images meet the required specifications. 
Step 3: Create Captcha Controller_ -_ Develop a REST Controller to expose the Captcha API endpoints for generation and validation. 

Generates a Captcha and returns it as a Base64-encoded string along with a unique Captcha ID and expiration time. 

Step 4: Develop Captcha Service_ -_ Create a service class to handle Captcha creation, conversion to Base64 format, and expiration logic.


        
      Generate Captcha text and image using DefaultKaptcha or Producer. 

        
      Convert the Captcha image to a Base64 string. 

        
      Set an expiration time for the Captcha based on configuration. 

Step 5: Create Captcha DAO and Repository 


        
      
Captcha Entity: Define a JPA entity to represent Captcha data, including: 
ID 
Captcha text 
Expiration time 
Request Id 
Request Type 

Created At 


        
      
Captcha Dao: To call the repository layer 


Captcha Repository: Use a Spring Data JPA repository to persist and retrieve Captcha information. 
Database Table- Captcha_Management



Column name


DataType


Nullable



ID
RAW
No


CAPTCHA_IMAGE
CLOB
No


EXPIRY_TIME
NUMBER
Yes


REQUEST_ID
RAW
No


REQUEST_TYPE
VARCHAR2(255 BYTE)
No


IS_VERIFIED
NUMBER(1,0)
Yes


CREATED_AT
NUMBER
No


UPDATED_AT
NUMBER
No


CAPTCHA_TEXT
VARCHAR2(200 BYTE)
Yes


VERSION
NUMBER
No


Summary of Key Components 


        
      
Library: Kaptcha for Captcha generation. 

        
      
Configuration: Defines Captcha appearance and behavior. 

        
      
Controller: Exposes endpoints for Captcha generation and validation. 

        
      
Service: Handles Captcha logic, including image creation, encoding, and storage. 

        
      
Repository: Stores Captcha data in the database for validation and expiration. 


Acceptance Criteria 


        
      Captcha should generate dynamically on each request with six random alphanumeric characters. 

        
      Captcha should expire after 5 minutes. 

        
      Validation should confirm the user-provided Captcha matches the stored Captcha. 

        
      Users can refresh the Captcha if needed. 

        
      All requests and responses must be logged for traceability. 


public class AlertDao 
/**
     * GenerateAlertForReport - sending alert for generated Report
     * @param reportAlertDto ReportAlertDto
     */
    public void generateAlertForReport(ReportAlertDto reportAlertDto) {
        AlertMaster alertMasterData = alertMasterRepository.findByName(MerchantConstant.REPORT_GENERATION).orElseThrow(()-> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Report Name")));
        AlertManagement alertManagement = AlertManagement.builder().alertId(alertMasterData.getId()).alertDescription(MessageFormat.format(alertMasterData.getDescription(), reportAlertDto.getReportName())).alertIdentifier(MerchantUtil.generateUnique12DigitNumber()).isViewed(false).mId(reportAlertDto.getMId()).build();
        log.info("generated Alert for ReportName: {}, mid : {}",reportAlertDto.getReportName(),reportAlertDto.getMId());
        alertManagementRepository.save(alertManagement);
    }
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReportAlertDto {
    private String mId;
    private String reportName;
}

@Component
@RequiredArgsConstructor
public class ReportAlertListener {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final ObjectMapper objectMapper;
    private final AlertService alertService;

    @KafkaListener(topics = "${spring.kafka.topic.alert}")
    public void onAlert(ConsumerRecord<String, String> consumerRecord) {
        log.debug("alert request received for key : {} and value : {}", consumerRecord.key(), consumerRecord.value());
        try {
            MDC.put(EPayAuthenticationConstant.CORRELATION_ID, String.valueOf(UUID.randomUUID()));
            MDC.put(EPayAuthenticationConstant.SCENARIO, "reportAlertListener");
            ReportAlertDto reportAlertDto = objectMapper.readValue(consumerRecord.value(), ReportAlertDto.class);
            alertService.generateAlertForReport(reportAlertDto);
        } catch (MerchantException e) {
            log.error("MerchantException while processing kafka listening message[key:{} and value: {}], error: {}", consumerRecord.key(), consumerRecord.value(), e.getErrorMessage());
        } catch (JsonProcessingException e) {
            log.error("Json parsing error while processing kafka listening message[key:{} and value: {}], error: {}", consumerRecord.key(), consumerRecord.value(), e.getMessage());
        }
    }
}
@@ public interface AlertManagementRepository extends JpaRepository<AlertManagement
    @Query("UPDATE AlertManagement a SET a.isViewed = true WHERE a.mId = :mId AND a.alertIdentifier = :alertIdentifier")
    void updateAlertViewStatus(@Param("mId") String mId, @Param("alertIdentifier") long alertIdentifier);

@@ -19,5 +20,6 @@ import java.util.UUID;
public interface AlertMasterRepository extends JpaRepository<AlertMaster, UUID> {

    List<AlertMaster> findAllByName(String name);
    

    Optional<AlertMaster> findByName(String reportName);
}
aLERTSERVICE

    /**
     * Update the report Status after it got downloaded
     *
     * @return
     */
    public void generateAlertForReport(ReportAlertDto reportAlertDto) {
        log.info("Updating reportStatus '{}'  for mID '{}'", reportAlertDto.getReportName(), reportAlertDto.getMId());
        alertDao.generateAlertForReport(reportAlertDto);
    }
merchantconstant
 public static final String REPORT_GENERATION = "Report Generation";

REATE TABLE ALERT_MANAGEMENT (
ALTER TABLE ALERT_MANAGEMENT ADD ALERT_DESCRIPTION VARCHAR2(500);

-- changeset Subhra:4
ALTER TABLE ALERT_MANAGEMENT ADD ALERT_IDENTIFIER NUMBER(20) UNIQUE;
\ No newline at end of file
ALTER TABLE ALERT_MANAGEMENT ADD ALERT_IDENTIFIER NUMBER(20) UNIQUE;


--changeset Rahul Kumar:3
INSERT INTO ALERT_MASTER(NAME, DESCRIPTION, CREATED_AT)
VALUES ('Report Generation', '{0} Report has been generated for download',
(SELECT ROUND(((TRUNC(SYSTIMESTAMP,'MI')-DATE '1970-01-01') * 24 * 60 * 60) + EXTRACT (SECOND FROM SYSTIMESTAMP), 3)*1000 FROM DUAL));
