/**
 * Validates the OTP and captcha for the given request, generates a user token if successful,
 * updates the OTP and captcha validation status in the database, and returns a success response.
 *
 * Steps:
 * 1. Validate the OTP validation request.
 * 2. Update OTP and captcha verification status in the database.
 * 3. Generate a user token for login requests and save the audit log.
 * 4. Build and return the success response.
 *
 * @param otpValidationRequest the OTP validation request containing the OTP, captcha, and request details
 * @return a {@link MerchantResponse} containing the status and a success message or token
 * @throws ValidationException if validation fails (e.g., invalid OTP or captcha)
 * @throws MerchantException   for business-related errors during processing
 */
public MerchantResponse<String> validateOtp(OtpValidationRequest otpValidationRequest) {
    try {
        // Step 1: Validate the OTP validation request
        log.info("Started OTP validation for RequestId: {}", otpValidationRequest.getRequestId());
        otpValidator.validateOtpValidationRequest(otpValidationRequest);

        // Step 2: Update the OTP and captcha verification status
        log.info("Updating OTP and captcha validation status for RequestId: {}", otpValidationRequest.getRequestId());
        otpManagementDao.updateOtpAndCaptchaStatus(otpValidationRequest.getRequestId());

        // Step 3: If it's a login request, generate a user token and save the audit log
        String responseMsg = MessageFormat.format(SUCCESS_MESSAGE, "otp validated");
        if (RequestType.LOGIN.equals(otpValidationRequest.getRequestType())) {
            log.info("Generating user token for RequestId: {}", otpValidationRequest.getRequestId());
            responseMsg = tokenService.generateUserToken(otpValidationRequest.getUserName());

            otpManagementDao.saveAudit(
                otpValidationRequest.getUserName(),
                otpValidationRequest.getRequestType(),
                true,
                MessageFormat.format(SUCCESS_MESSAGE, "otp validated")
            );
        }

        // Step 4: Build and return the success response
        return MerchantResponse.<String>builder()
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .data(List.of(responseMsg))
                .build();
    } catch (ValidationException e) {
        handleOtpValidationFailure(otpValidationRequest.getUserName(), otpValidationRequest.getRequestType(), e.getErrorMessages());
        log.error("OTP validation failed for RequestId: {}", otpValidationRequest.getRequestId(), e);
        throw e;
    } catch (MerchantException e) {
        handleOtpValidationFailure(otpValidationRequest.getUserName(), otpValidationRequest.getRequestType(), List.of(e.getMessage()));
        log.error("OTP validation failed for RequestId: {}", otpValidationRequest.getRequestId(), e);
        throw e;
    } catch (Exception e) {
        handleOtpValidationFailure(otpValidationRequest.getUserName(), otpValidationRequest.getRequestType(), List.of(e.getLocalizedMessage()));
        log.error("OTP validation failed for RequestId: {}", otpValidationRequest.getRequestId(), e);
        throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, ErrorConstants.GENERATION_ERROR_MESSAGE);
    }
}

/**
 * Handles OTP validation failure.
 *
 * This method is invoked whenever OTP validation fails due to any reason.
 * It performs the following steps:
 * 1. Updates the merchant user login status to false.
 * 2. Saves the audit log with the failure details.
 * 
 * @param userName the username of the merchant user for whom OTP validation failed
 * @param requestType the type of request (e.g., LOGIN, TRANSACTION) during which the failure occurred
 * @param errorMessage the error message or reason for the failure
 */
private void handleOtpValidationFailure(String userName, RequestType requestType, String errorMessage) {
    if (StringUtils.isNotEmpty(userName)) {
        // Step 1: Update the user's login status to false
        tokenService.updateMerchantUserForLogin(userName, false);

        // Step 2: Save the failure details to the audit log
        otpManagementDao.saveAudit(userName, requestType, false, errorMessage);

        log.info("Handled OTP validation failure for userName: {}, requestType: {}, reason: {}", userName, requestType, errorMessage);
    } else {
        log.warn("Unable to handle OTP validation failure due to missing userName.");
    }
}



@Transactional
    public OnboardingDto onboardingMerchantAndMerchantUser(OnboardingRequest onboardingRequest) {
        // Step 1 : Onboard Merchant
        MerchantInfo merchantInfo = mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant());
        merchantInfo.setStatus(MerchantStatus.ACTIVE.name());
        merchantInfo = merchantRepository.save(merchantInfo);
        // Step 2 : Onboard Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.saveMerchantUser(onboardingRequest.getUser(), merchantInfo.getMId());
        // Step 3 : Build Onboarding response
        return OnboardingDto.builder().merchant(mapper.mapMerchantInfoEntityToDto(merchantInfo)).user(merchantUserDto).build();
    }

    public boolean isMerchantExistByMId(String mId) {
        return merchantRepository.existsBymIdAndStatus(mId, MerchantStatus.ACTIVE.name());
    }

package com.epay.merchant.mapper;

import com.epay.merchant.dto.HelpSupportDto;
import com.epay.merchant.dto.MerchantDto;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.entity.HelpSupport;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.entity.MerchantUser;
import com.epay.merchant.model.request.MerchantUserRequest;
import com.epay.merchant.model.response.MerchantInfoResponse;
import com.epay.merchant.model.response.MerchantUserResponse;
import com.epay.merchant.model.response.UserProfileResponse;
import org.mapstruct.AfterMapping;
import org.mapstruct.Builder;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

import java.util.List;

@Mapper(builder = @Builder(disableBuilder = true), componentModel = "spring")
public interface MerchantMapper {
    MerchantUser mapMerchantUserDtoToEntity(MerchantUserDto merchantUserDto);

    MerchantUserDto mapMerchantUserEntityToDto(MerchantUser merchantUser);

    List<MerchantUserResponse> mapMerchantUserDTOListToResponseList(List<MerchantUserDto> merchantUserDtos);

    MerchantInfo mapMerchantDtoToEntity(MerchantDto merchant);

    @AfterMapping
    default void afterMapMerchantDtoToEntity(MerchantDto merchantDto, @MappingTarget MerchantInfo merchantInfo) {
        merchantInfo.setMId(merchantDto.getMId());
        merchantInfo.setChargebackAllowed(merchantDto.isChargebackAllowed());
    }

    MerchantDto mapMerchantInfoEntityToDto(MerchantInfo merchantInfo);

    @AfterMapping
    default void afterMapMerchantInfoEntityToDto(MerchantInfo merchantInfo, @MappingTarget MerchantDto merchantDto) {
        merchantDto.setMId(merchantInfo.getMId());
        merchantDto.setChargebackAllowed(merchantInfo.isChargebackAllowed());
    }

    MerchantInfoDto mapMerchantInfoEntityToMerchantInfoDto(MerchantInfo merchantInfo);

    List<MerchantInfoResponse> mapMerchantInfoDTOListToResponseList(List<MerchantInfoDto> MerchantInfoDtos);

    MerchantUserResponse mapMerchantUserEntityToResponse(MerchantUser merchantUser);

    UserProfileResponse mapMerchantUserEntityToProfileResponse(MerchantUser merchantUser);

    MerchantUserResponse mapMerchantUserDtoToResponse(MerchantUserDto merchantUserDto);

    MerchantUserDto mapMerchantUserRequestToMerchantUserDto(MerchantUserRequest merchantUserRequest);

    List<HelpSupportDto> mapListHelpSupportEntityToResponse(List<HelpSupport> helpSupports);
}



    @Transactional
    public MerchantUserDto saveMerchantUser(MerchantUserDto merchantUserDto, String... mIds) {
        //Step 1 : Password Generator
        String password = passwordGenerator.generatePassword();

        //Step 2 : Set Up Default Value
        setMerchantUserDefaultValues(merchantUserDto, password);

        //Step 3 : Save Merchant User
        MerchantUser merchantUser = merchantMapper.mapMerchantUserDtoToEntity(merchantUserDto);
        merchantUser = merchantUserRepository.save(merchantUser);

        //Step 4 : Assigned MIDs to Merchant User
        assignMerchantToUser(merchantUser.getId(), mIds);

        //Step 5 : Assigned Default Menu permission to Merchant User
        createMerchantUserMenuPermissions(merchantUser.getId(), merchantUser.getRole());

        //Step 5 : Send Notification
        sendNotification(merchantUser, password);

        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }


 @Test
    public void onboardingTest() {
        MerchantInfo merchantInfoEntity = mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant());
       /* Mockito.when(mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant())).thenReturn(merchantInfoEntity);*/
       /* when(mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant())).thenReturn(merchantInfoEntity);
       */ merchantInfoEntity.setId(UUID.randomUUID());
        Mockito.when(merchantRepo.save(Mockito.any())).thenReturn(merchantInfoEntity);
        MerchantDto merchantDto = mapper.mapMerchantInfoEntityToDto(merchantInfoEntity);
        Mockito.when(mapper.mapMerchantInfoEntityToDto(merchantInfoEntity)).thenReturn(merchantDto);

        MerchantUser merchantUserEntity = mapper.mapMerchantUserDtoToEntity(onboardingRequest.getUser());
        Mockito.when(mapper.mapMerchantUserDtoToEntity(onboardingRequest.getUser())).thenReturn(merchantUserEntity);
        merchantUserEntity.setId(UUID.randomUUID());
        MerchantUserRole role = new MerchantUserRole();
        role.setId(UUID.randomUUID());
        role.setRole(MerchantUserRoles.ADMIN.name());
        Mockito.when(userRoleRepo.findByRole(MerchantUserRoles.ADMIN.name())).thenReturn(Optional.of(role));
        Mockito.when(merchantUserRepo.save(Mockito.any())).thenReturn(merchantUserEntity);
        MerchantUserDto merchantUserDto = mapper.mapMerchantUserEntityToDto(merchantUserEntity);
        Mockito.when(mapper.mapMerchantUserEntityToDto(merchantUserEntity)).thenReturn(merchantUserDto);
        MenuInfo menu = new MenuInfo();
        menu.setId(UUID.randomUUID());
        Mockito.when(menuInfoRepo.findAll()).thenReturn(List.of(menu));
        DefaultUserPermission defaultUserPermission = new DefaultUserPermission();
        defaultUserPermission.setMenuId(menu.getId());
        Mockito.when(defaultUserPermissionRepo.findByRoleId(role.getId())).thenReturn(List.of(defaultUserPermission));

        OnboardingDto onboardingRequestRes = adminDao.onboardingMerchantAndMerchantUser(onboardingRequest);
        assertNotNull(onboardingRequestRes.getMerchant().getMId());
    }





@Test
void onboardingMerchantAndMerchantUserTest_Success() {
    // Given: Mock Merchant Info setup
    MerchantInfo merchantInfo = new MerchantInfo();
    merchantInfo.setMId("test-mId");
    merchantInfo.setStatus(MerchantStatus.ACTIVE.name());
    Mockito.when(mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant())).thenReturn(merchantInfo);
    Mockito.when(merchantRepo.save(Mockito.any())).thenAnswer(invocation -> {
        MerchantInfo savedMerchant = invocation.getArgument(0);
        savedMerchant.setId(UUID.randomUUID());
        return savedMerchant;
    });

    MerchantDto merchantDto = new MerchantDto();
    merchantDto.setMId("test-mId");
    Mockito.when(mapper.mapMerchantInfoEntityToDto(Mockito.any())).thenReturn(merchantDto);

    // Given: Mock Merchant User setup
    MerchantUser merchantUser = new MerchantUser();
    merchantUser.setId(UUID.randomUUID());
    Mockito.when(mapper.mapMerchantUserDtoToEntity(onboardingRequest.getUser())).thenReturn(merchantUser);
    Mockito.when(merchantUserRepo.save(Mockito.any())).thenReturn(merchantUser);

    MerchantUserDto merchantUserDto = new MerchantUserDto();
    merchantUserDto.setId(UUID.randomUUID());
    Mockito.when(mapper.mapMerchantUserEntityToDto(merchantUser)).thenReturn(merchantUserDto);

    // Given: Mock Role Setup
    MerchantUserRole role = new MerchantUserRole();
    role.setId(UUID.randomUUID());
    role.setRole(MerchantUserRoles.ADMIN.name());
    Mockito.when(userRoleRepo.findByRole(MerchantUserRoles.ADMIN.name())).thenReturn(Optional.of(role));

    // Given: Mock Menu Permissions
    MenuInfo menu = new MenuInfo();
    menu.setId(UUID.randomUUID());
    Mockito.when(menuInfoRepo.findAll()).thenReturn(List.of(menu));

    DefaultUserPermission defaultPermission = new DefaultUserPermission();
    defaultPermission.setMenuId(menu.getId());
    Mockito.when(defaultUserPermissionRepo.findByRoleId(role.getId())).thenReturn(List.of(defaultPermission));

    // When: Execute Onboarding
    OnboardingDto onboardingResponse = adminDao.onboardingMerchantAndMerchantUser(onboardingRequest);

    // Then: Assertions
    assertNotNull(onboardingResponse, "Onboarding response should not be null");
    assertNotNull(onboardingResponse.getMerchant(), "Merchant information should not be null");
    assertNotNull(onboardingResponse.getMerchant().getMId(), "Merchant ID should not be null");
    assertNotNull(onboardingResponse.getUser(), "Merchant User should not be null");
    verify(merchantRepo).save(Mockito.any());
    verify(merchantUserRepo).save(Mockito.any());
    verify(userRoleRepo).findByRole(MerchantUserRoles.ADMIN.name());
    verify(menuInfoRepo).findAll();
    verify(defaultUserPermissionRepo).findByRoleId(role.getId());
}
