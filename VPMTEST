 public void validatePostMapping(String userName, MerchantUserDto merchantUser, List<String> mIds) {
        checkMandatoryCollection(mIds, "List of mIds");
        validatedMappingRequest(userName, merchantUser);
        validatedWithParentMIdsAccess(mIds, merchantUser);
    }

    public void validatedMappingRequest(String userName, MerchantUserDto merchantUser) {
        String loggedInUserName = EPayIdentityUtil.getUserPrincipal().getUsername();
        if (!loggedInUserName.equalsIgnoreCase(userName) || ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            MerchantUserDto loggedInUser = merchantUserDao.getByUserName(loggedInUserName, List.of(UserStatus.ACTIVE));
            // Validated if LoggedIn user is the parent of requested User Or Not
            if (!loggedInUser.getId().equals(merchantUser.getParentUserId())) {
                throw new ValidationException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "Mapping Request", "Logged In User is not a direct parent of request user"));
            }
        }
    }

    public void validatedWithParentMIdsAccess(List<String> mIds, MerchantUserDto merchantUser) {
        String username = EPayIdentityUtil.getUserPrincipal().getUsername();
        MerchantUserDto loggedInUser = merchantUserDao.getByUserName(username, List.of(UserStatus.ACTIVE));
        List<String> parentMIdsList = new ArrayList<>();
        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId()) && loggedInUser.getId().equals(merchantUser.getParentUserId())) {
            // Get Parent Assigned MIDs List
            List<MerchantInfoDto> parentAssignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(merchantUser.getParentUserId());
            parentMIdsList = parentAssignedMIds.stream().map(MerchantInfoDto::getMId).toList();
        }
        if (!new HashSet<>(parentMIdsList).containsAll(mIds)) {
            throw new ValidationException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "Requested AssginedMIds", "Requested User is not having the access of given MId list"));
        }
    }
 void validateIsRolePresent(MerchantUserRequest merchantUserRequest) {
        errorDtoList = new ArrayList<>();
        checkMandatoryField(merchantUserRequest.getRole(), "User Role");
        throwIfErrors();
    }
 void validateDuplicateMerchantUserOnUpdate(String userName, String email, String mobilePhone) {
        List<String> dbUserName = merchantUserDao.getUserNameByEmailOrMobilePhone(email, mobilePhone);
        boolean found = dbUserName.stream().allMatch(u -> u.equalsIgnoreCase(userName));
        if (!found) {
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.ALREADY_EXIST_ERROR_CODE).errorMessage(MessageFormat.format(USER_ALREADY_EXIST_ERROR_MESSAGE_UPDATE, email, mobilePhone)).build());
            throwIfErrors();
        }
    }



package com.epay.merchant.service;

import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.dao.MerchantUserDao;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.request.MerchantUserGetRequest;
import com.epay.merchant.model.request.MerchantUserRequest;
import com.epay.merchant.model.response.*;
import com.epay.merchant.util.EPayIdentityUtil;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.UserStatus;
import com.epay.merchant.validator.MerchantUserValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * *
 * Description:
 * *
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantUserValidator merchantUserValidator;
    private final MerchantMapper merchantMapper;

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private static List<String> getNewMIdMappingList(List<String> mIds, List<MerchantInfoDto> assignedMIds) {
        List<String> newMappedMIds = new ArrayList<>();
        for (String mId : mIds) {
            boolean mIdFound = false;
            for (MerchantInfoDto assignedMId : assignedMIds) {
                if (mId.equalsIgnoreCase(assignedMId.getMId())) {
                    mIdFound = true;
                    break;
                }
            }
            if (!mIdFound) {
                newMappedMIds.add(mId);
            }
        }
        return newMappedMIds;
    }

    /**
     * Fetches all merchant information with pagination
     */
    public MerchantResponse<MerchantInfoResponse> getAllAccessMerchantInfo(Pageable pageable) {
        log.info("Fetching all merchant information");

        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get All Merchant Info which is accessible to Logged in Merchant User
        Page<MerchantInfoDto> merchantInfo = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName, pageable);

        // Step 3 : Covert DTO to Response Object
        List<MerchantInfoResponse> merchantInfoResponseList = merchantMapper.mapMerchantInfoDTOListToResponseList(merchantInfo.getContent());

        // Step 4 : Building the response
        return MerchantResponse.<MerchantInfoResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(merchantInfoResponseList).count(merchantInfo.stream().count()).total(merchantInfo.getTotalElements()).build();
    }

    /**
     * Find Merchant User basic information and Access details
     */
    public MerchantResponse<MerchantUserAccessResponse> getMerchantUserAccess() {
        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.getByUserName(userName, List.of(UserStatus.ACTIVE));
        if (ObjectUtils.isEmpty(merchantUserDto)) {
            throw new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName"));
        }

        // Step 3 : Get Merchant Permission Info of Logged in Merchant User
        List<UserMenuPermissionEntityDetails> userAccess = merchantUserDao.getUserMenuPermission(merchantUserDto.getId());

        // Step 4 : Build Merchant User Access Response
        MerchantUserAccessResponse merchantUserAccessResponse = MerchantUserAccessResponse.builder().userInfo(merchantUserDto).userAccess(userAccess).build();

        // Step 4 : Building the response
        return MerchantResponse.<MerchantUserAccessResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(merchantUserAccessResponse)).build();
    }

    /**
     * Fetches Merchant User profile details for Logged-In User
     */
    public MerchantResponse<UserProfileResponse> getMerchantUserProfile() {

        // Step 1 : Get UserName from Security Context
        String userName = EPayIdentityUtil.getUserPrincipal().getUsername();

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        UserProfileResponse userProfileResponse = merchantUserDao.getMerchantUserProfile(userName, List.of(UserStatus.ACTIVE));

        // Step 3 : Building the response
        return MerchantResponse.<UserProfileResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(userProfileResponse)).count(1L).total(1L).build();
    }

    /**
     * Merchant User Creation
     *
     * @param merchantUserRequest MerchantUserRequest
     * @return MerchantUserResponse
     */
    public MerchantResponse<MerchantUserResponse> createMerchantUser(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, true);
        return saveMerchantUser(merchantUserRequest, false, false);
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUser(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserRequest(merchantUserRequest, false);
        return saveMerchantUser(merchantUserRequest, false, true);
    }

    public MerchantResponse<MerchantUserResponse> updateMerchantUserProfile(MerchantUserRequest merchantUserRequest) {
        //Step 1 : MerchantUserRequest validation
        merchantUserValidator.validateMerchantUserProfile(merchantUserRequest);
        return saveMerchantUser(merchantUserRequest, true, true);
    }

    private MerchantResponse<MerchantUserResponse> saveMerchantUser(MerchantUserRequest merchantUserRequest, boolean isProfileUpdate, boolean isUpdate) {
        //Step 1 : Save the Merchant User Data in DB
        MerchantUserDto merchantUserDto = merchantMapper.mapMerchantUserRequestToMerchantUserDto(merchantUserRequest);
        if (isUpdate) {
            merchantUserDto = merchantUserDao.updateMerchantUser(merchantUserDto, isProfileUpdate);
        } else {
            merchantUserDto = merchantUserDao.saveMerchantUser(merchantUserDto, StringUtils.EMPTY);
        }
        //Step 2 : Build MerchantResponse and return to caller
        MerchantUserResponse merchantUserResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        merchantUserResponse.setRole(merchantUserDao.getUserRoleName(merchantUserDto.getRole()));
        return MerchantResponse.<MerchantUserResponse>builder().data(List.of(merchantUserResponse)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).build();
    }

    /**
     * Search Merchant User and return all records based on search inputs.
     *
     * @param merchantUserGetRequest MerchantUserRequest
     * @return MerchantUserResponse of MerchantUser
     */
    public MerchantResponse<MerchantUserResponse> searchMerchantUsers(MerchantUserGetRequest merchantUserGetRequest) {
        Page<MerchantUserDto> merchantUsers = merchantUserDao.findMerchantUsers(merchantUserGetRequest);
        List<MerchantUserResponse> merchantUserResponseList = merchantMapper.mapMerchantUserDTOListToResponseList(merchantUsers.getContent());
        return MerchantResponse.<MerchantUserResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(merchantUserResponseList).count(merchantUsers.stream().count()).total(merchantUsers.getTotalElements()).build();
    }

    /**
     * Fetch User Roles
     *
     * @return MerchantResponse<UserRoleResponse> containing user roles
     */
    public MerchantResponse<UserRoleResponse> getUserRole() {
        log.info("Started fetching user roles");
        List<UserRoleResponse> userRoleResponse = merchantUserDao.getUserRoles();
        return MerchantResponse.<UserRoleResponse>builder().data(userRoleResponse).status(MerchantConstant.RESPONSE_SUCCESS).count((long) userRoleResponse.size()).build();
    }

    /**
     * Retrieves MID mapping list based on user ID and parent MID list.
     *
     * @param userName String.
     * @return MerchantResponse containing assigned and unassigned MIDs.
     */
    public MerchantResponse<MerchantUserAssignedMIdsResponse> getAssignedUnAssignedMIdsOfUser(String userName) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, List.of(UserStatus.ACTIVE));

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatedMappingRequest(userName, merchantUser);

        //Step 3  : Get Assigned MIds
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);

        //Step 4  : Get UnAssigned MIds from ParentUser
        List<MerchantInfoResponse> unAssignedMerchantInfo = getParentAssignedMIds(merchantUser, assignedMIds);

        //Step 5  : Build MerchantUserAssignedMIdsResponse
        List<MerchantInfoResponse> assignedMerchantInfo = merchantMapper.mapMerchantInfoDTOListToResponseList(assignedMIds);
        MerchantUserAssignedMIdsResponse userAssignedMIdsResponse = MerchantUserAssignedMIdsResponse.builder().assignedMIds(assignedMerchantInfo).unAssignedMIds(unAssignedMerchantInfo).build();

        //Step 6 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<MerchantUserAssignedMIdsResponse>builder().data(List.of(userAssignedMIdsResponse)).build();
    }

    /**
     * Retrieves MID mapping list based on user ID and parent MID list.
     *
     * @param userName String.
     * @return MerchantResponse containing assigned and unassigned MIDs.
     */
    public MerchantResponse<String> assignedMIdsToUser(String userName, List<String> mIds) {
        //Step 1  : Get Requested User Information
        MerchantUserDto merchantUser = merchantUserDao.getByUserName(userName, List.of(UserStatus.ACTIVE));

        //Step 2: Get LoggedIn USer Information to validated with requested Us̥er Parent data
        merchantUserValidator.validatePostMapping(userName, merchantUser, mIds);

        //Step 3  : Build Remove and new Assigned MIds list from current data
        List<MerchantInfoDto> assignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(userName);
        List<String> removedMIds = assignedMIds.stream().map(MerchantInfoDto::getMId).filter(mId -> !mIds.contains(mId)).collect(Collectors.toList());
        List<String> newMappedMIds = getNewMIdMappingList(mIds, assignedMIds);

        //Step 4 : Update the data in DB as per remove and new MIDs list
        merchantUserDao.assignedMIds(newMappedMIds, removedMIds, merchantUser.getId());

        //Step 5 :  Build MerchantResponse Object of MerchantUserAssignedMIdsResponse
        return MerchantResponse.<String>builder().data(List.of("MIds is assigned Successfully")).build();
    }

    private List<MerchantInfoResponse> getParentAssignedMIds(MerchantUserDto merchantUser, List<MerchantInfoDto> assignedMIds) {
        List<MerchantInfoResponse> unAssignedMerchantInfo = new ArrayList<>();

        if (ObjectUtils.isNotEmpty(merchantUser.getParentUserId())) {
            //Step 2: Get Parent Assigned MIDs List
            List<MerchantInfoDto> parentAssignedMIds = merchantInfoDao.getAllAccessMerchantInfoForMerchantUser(merchantUser.getParentUserId());

            //Step 3: Remove Assigned MIDs List from Parent Assigned MIDs List
            parentAssignedMIds.removeAll(assignedMIds);
            if (CollectionUtils.isNotEmpty(parentAssignedMIds)) {
                unAssignedMerchantInfo.addAll(merchantMapper.mapMerchantInfoDTOListToResponseList(parentAssignedMIds));
            }
        }
        return unAssignedMerchantInfo;
    }
}
