
@RestController
@RequiredArgsConstructor
@RequestMapping("/key")
@Validated
public class KeyController {

    private final KeyService keyService;

    /**
     * Generates a key (API or Encryption) for a merchant.
     *
     * @param type                The type of key to generate (API or Encryption).
     * @param keyGenerationRequest Request body containing key generation details.
     * @param response            HTTP response object for sending the generated file.
     */
    @PostMapping("/generation/{type}")
    @Operation(summary = "Generate a key for the merchant", description = "Generates API or Encryption key for a merchant.")
    public void generateKey(@PathVariable("type") KeyType type, 
                            @RequestBody KeyGenerationRequest keyGenerationRequest, 
                            HttpServletResponse response) {
        keyService.generateKey(type, keyGenerationRequest, response);
    }

    /**
     * Validates an API key against the database.
     *
     * @param apiKeyValidationRequest Request body containing API key validation details.
     * @return MerchantResponse containing validation status.
     */
    @PostMapping("/validated/api")
    @Operation(summary = "Validate API Keys for a merchant", description = "Validates API keys for the provided merchant ID.")
    public MerchantResponse<String> validatedAPIKey(@RequestBody @Valid APIKeyValidationRequest apiKeyValidationRequest) {
        return keyService.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * Fetches encryption keys for the given merchant ID.
     *
     * @param mId Merchant ID for which encryption keys are to be fetched.
     * @return MerchantResponse containing encryption key details.
     */
    @GetMapping("/encryption/{mId}")
    @Operation(summary = "Fetch encryption keys for a merchant", description = "Retrieves encryption keys for the given merchant ID.")
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(@PathVariable String mId) {
        return keyService.getMerchantEncryptionKeys(mId);
    }

    /**
     * Retrieves a list of keys for the given merchant ID and key type.
     *
     * @param keyType Key type to filter (API or Encryption).
     * @param mId     Merchant ID for which keys are to be fetched.
     * @param pageable Pageable object for pagination support.
     * @return MerchantResponse containing the list of keys.
     */
    @GetMapping("/{mId}/{keyType}")
    @Operation(summary = "Fetch keys for a merchant", description = "Retrieves keys for the given merchant ID and key type.")
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(@PathVariable("keyType") KeyType keyType, 
                                                              @PathVariable("mId") String mId, 
                                                              @PageableDefault(size = 50, page = 0) Pageable pageable) {
        return keyService.getKeysByMerchant(keyType, mId, pageable);
    }
}


@Service
@RequiredArgsConstructor
public class KeyService {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(KeyService.class);
    private final KeyValidator keyValidator;
    private final KeyDao keyDao;
    private final PasswordGenerator passwordGenerator;

    /**
     * Handles the generation of keys (API or Encryption) for merchants.
     * Logs details about the key generation process and errors, if any.
     *
     * @param type                The type of key to generate (API or Encryption).
     * @param keyGenerationRequest Request body containing key generation details.
     * @param response            HTTP response object for sending the generated file.
     */
    public void generateKey(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        logger.info("Starting key generation process for Merchant ID: {}", keyGenerationRequest.getMId());
        ByteArrayOutputStream pdfStream;

        // Validate the request
        keyValidator.validateKeyGenerationRequest(keyGenerationRequest);

        // Generate the key based on the type
        try {
            switch (type) {
                case API -> pdfStream = apiKeyGeneration(keyGenerationRequest);
                case ENCRYPTION -> pdfStream = encryptionKeyGeneration(keyGenerationRequest);
                default -> throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE,
                        MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "KeyType", Arrays.toString(KeyType.values())));
            }

            // Send the generated file in the response
            fileResponse(type, keyGenerationRequest, response, pdfStream);
            logger.info("Key generation process completed successfully for Merchant ID: {}", keyGenerationRequest.getMId());

        } catch (Exception e) {
            logger.error("Error occurred during key generation for Merchant ID: {}", keyGenerationRequest.getMId(), e);
            throw e;
        }
    }

    /**
     * Validates an API key and returns the validation status.
     * Logs the validation process and potential errors.
     *
     * @param apiKeyValidationRequest Request body containing API key validation details.
     * @return MerchantResponse containing validation status.
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        logger.info("Validating API key for Merchant ID: {}", apiKeyValidationRequest.getMId());
        keyValidator.validateAPIKeyValidationRequest(apiKeyValidationRequest);
        return keyDao.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * Retrieves encryption keys for a given merchant ID.
     * Logs the retrieval process and potential errors.
     *
     * @param mId Merchant ID for which encryption keys are fetched.
     * @return MerchantResponse containing encryption key details.
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        logger.info("Fetching encryption keys for Merchant ID: {}", mId);
        keyValidator.validateMId(mId);
        return keyDao.getMerchantEncryptionKeys(mId);
    }

    /**
     * Fetches the keys associated with a given merchant ID and key type.
     * Logs the retrieval process and any errors encountered.
     *
     * @param keyType Key type to filter (API or Encryption).
     * @param mId     Merchant ID for which keys are fetched.
     * @param pageable Pageable object for pagination.
     * @return MerchantResponse containing the list of keys.
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        logger.info("Fetching keys for Merchant ID: {} and Key Type: {}", mId, keyType);
        return keyDao.getKeysByMerchant(keyType, mId, pageable);
    }
}

@Repository
@RequiredArgsConstructor
public class KeyDao {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(KeyDao.class);
    private final JdbcTemplate jdbcTemplate;

    /**
     * Validates an API key against the database.
     * Logs the validation process, including the merchant ID and potential errors.
     *
     * @param apiKeyValidationRequest Request containing API key and merchant ID.
     * @return MerchantResponse containing validation status.
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        logger.info("Starting API key validation for Merchant ID: {}", apiKeyValidationRequest.getMId());

        try {
            String sql = "SELECT status FROM merchant_keys WHERE m_id = ? AND api_key = ?";
            String status = jdbcTemplate.queryForObject(
                    sql,
                    new Object[]{apiKeyValidationRequest.getMId(), apiKeyValidationRequest.getApiKey()},
                    String.class
            );

            logger.info("API key validation completed for Merchant ID: {}. Status: {}", apiKeyValidationRequest.getMId(), status);
            return new MerchantResponse<>(status);

        } catch (EmptyResultDataAccessException e) {
            logger.warn("No matching API key found for Merchant ID: {}", apiKeyValidationRequest.getMId());
            throw new MerchantException(ErrorConstants.KEY_NOT_FOUND_ERROR_CODE, 
                                         ErrorConstants.KEY_NOT_FOUND_ERROR_MESSAGE);
        } catch (Exception e) {
            logger.error("Error occurred during API key validation for Merchant ID: {}", apiKeyValidationRequest.getMId(), e);
            throw e;
        }
    }

    /**
     * Fetches encryption keys for the given merchant ID from the database.
     * Logs the retrieval process, including the merchant ID and any errors.
     *
     * @param mId Merchant ID for which encryption keys are retrieved.
     * @return MerchantResponse containing encryption key details.
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        logger.info("Fetching encryption keys for Merchant ID: {}", mId);

        try {
            String sql = "SELECT encryption_key, key_status FROM merchant_keys WHERE m_id = ? AND key_type = 'ENCRYPTION'";
            List<KMSEncryptionKeysResponse> keys = jdbcTemplate.query(
                    sql,
                    new Object[]{mId},
                    (rs, rowNum) -> new KMSEncryptionKeysResponse(
                            rs.getString("encryption_key"),
                            rs.getString("key_status")
                    )
            );

            logger.info("Successfully fetched encryption keys for Merchant ID: {}", mId);
            return new MerchantResponse<>(keys);

        } catch (Exception e) {
            logger.error("Error occurred while fetching encryption keys for Merchant ID: {}", mId, e);
            throw e;
        }
    }

    /**
     * Retrieves a paginated list of keys for the given merchant ID and key type.
     * Logs the retrieval process, including pagination details and potential errors.
     *
     * @param keyType Key type to filter (API or Encryption).
     * @param mId     Merchant ID for which keys are retrieved.
     * @param pageable Pageable object for pagination.
     * @return MerchantResponse containing the list of keys.
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        logger.info("Fetching keys for Merchant ID: {} and Key Type: {} with pagination: page={}, size={}",
                mId, keyType, pageable.getPageNumber(), pageable.getPageSize());

        try {
            String sql = "SELECT key_id, key_value, key_status FROM merchant_keys " +
                         "WHERE m_id = ? AND key_type = ? " +
                         "LIMIT ? OFFSET ?";
            List<KMSKeyResponse> keys = jdbcTemplate.query(
                    sql,
                    new Object[]{
                            mId,
                            keyType.name(),
                            pageable.getPageSize(),
                            pageable.getPageNumber() * pageable.getPageSize()
                    },
                    (rs, rowNum) -> new KMSKeyResponse(
                            rs.getString("key_id"),
                            rs.getString("key_value"),
                            rs.getString("key_status")
                    )
            );

            logger.info("Successfully fetched {} keys for Merchant ID: {} and Key Type: {}", keys.size(), mId, keyType);
            return new MerchantResponse<>(keys);

        } catch (Exception e) {
            logger.error("Error occurred while fetching keys for Merchant ID: {} and Key Type: {}", mId, keyType, e);
            throw e;
        }
    }
}


@Component
@RequiredArgsConstructor
public class KeyValidator {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(KeyValidator.class);

    private final KeyDao keyDao;

    /**
     * Validates an API key for a given merchant.
     * Logs the validation process, including the merchant ID and potential errors.
     *
     * @param apiKeyValidationRequest Request containing API key and merchant ID.
     * @return true if the API key is valid; false otherwise.
     */
    public boolean validateAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        logger.info("Initiating API key validation for Merchant ID: {}", apiKeyValidationRequest.getMId());

        try {
            MerchantResponse<String> response = keyDao.validatedAPIKey(apiKeyValidationRequest);

            if (response != null && "ACTIVE".equalsIgnoreCase(response.getData())) {
                logger.info("API key validation successful for Merchant ID: {}", apiKeyValidationRequest.getMId());
                return true;
            }

            logger.warn("API key validation failed for Merchant ID: {}. Status: {}", 
                        apiKeyValidationRequest.getMId(), 
                        response != null ? response.getData() : "No Data");
            return false;

        } catch (MerchantException e) {
            logger.error("MerchantException during API key validation for Merchant ID: {}. Error Code: {}, Message: {}",
                         apiKeyValidationRequest.getMId(),
                         e.getErrorCode(),
                         e.getMessage());
            return false;
        } catch (Exception e) {
            logger.error("Unexpected error during API key validation for Merchant ID: {}", 
                         apiKeyValidationRequest.getMId(), e);
            return false;
        }
    }

    /**
     * Validates the encryption keys for a given merchant.
     * Logs the validation process, including merchant ID and key status.
     *
     * @param mId Merchant ID whose encryption keys are validated.
     * @return true if encryption keys are valid; false otherwise.
     */
    public boolean validateMerchantEncryptionKeys(String mId) {
        logger.info("Validating encryption keys for Merchant ID: {}", mId);

        try {
            MerchantResponse<KMSEncryptionKeysResponse> response = keyDao.getMerchantEncryptionKeys(mId);

            if (response != null && !response.getData().isEmpty()) {
                boolean allKeysActive = response.getData().stream()
                        .allMatch(key -> "ACTIVE".equalsIgnoreCase(key.getKeyStatus()));

                if (allKeysActive) {
                    logger.info("All encryption keys are valid and active for Merchant ID: {}", mId);
                    return true;
                } else {
                    logger.warn("Some encryption keys are inactive for Merchant ID: {}", mId);
                }
            } else {
                logger.warn("No encryption keys found for Merchant ID: {}", mId);
            }

            return false;

        } catch (Exception e) {
            logger.error("Error occurred while validating encryption keys for Merchant ID: {}", mId, e);
            return false;
        }
    }
}

package com.epay.merchant.controller;

import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.service.KeyService;
import com.epay.merchant.util.enums.KeyType;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;


/**
 * Class Name: MerchantController
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@RestController
@RequiredArgsConstructor
@RequestMapping("/key")
@Validated
public class KeyController {

    private final KeyService keyService;

    /**
     * Generate Key
     * @param type KeyType
     * @param keyGenerationRequest KeyGenerationRequest
     * @param response HttpServletResponse
     */
    @PostMapping("/generation/{type}")
    @Operation(summary = "Generate the API and Encryption Key for a Merchant.", description = "Generate the API and Encryption Key for a Merchant.")
    public void generateKey(@PathVariable("type") KeyType type, @RequestBody KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        keyService.generateKey(type, keyGenerationRequest, response);
    }

    /**
     * Validated API Key
     * @param apiKeyValidationRequest APIKeyValidationRequest
     * @return MerchantResponse
     */
    @PostMapping("/validated/api")
    @Operation(summary = "Validate API Keys for Given MID", description = "Validate API Keys for Given MID")
    public MerchantResponse<String> validatedAPIKey(@RequestBody @Valid APIKeyValidationRequest apiKeyValidationRequest) {
        return keyService.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * Get Merchant Encryption Keys
     * @param mId String
     * @return MerchantResponse
     */
    @GetMapping("/encryption/{mId}")
    @Operation(summary = "Get Encryption Keys for Given MID", description = "Get Encryption Keys for Given MID")
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(@PathVariable String mId) {
        return keyService.getMerchantEncryptionKeys(mId);
    }

    /**
     * Get Keys By Merchant
     * @param keyType KeyType
     * @param mId String
     * @param pageable Pageable
     * @return MerchantResponse
     */
    @GetMapping("/{mId}/{keyType}")
    @Operation(summary = "Get list of keys for given MID", description = "Get list of keys for given MID")
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(@PathVariable("keyType") KeyType keyType, @PathVariable("mId") String mId,  @PageableDefault(size = 50, page = 0) Pageable pageable) {
        return keyService.getKeysByMerchant(keyType, mId, pageable);
    }


}
package com.epay.merchant.service;

import com.epay.merchant.dao.KeyDao;
import com.epay.merchant.document.pdf.APIKeyPDFBuilder;
import com.epay.merchant.document.pdf.EncryptionKeyPDFBuilder;
import com.epay.merchant.document.pdf.PDFService;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.PasswordGenerator;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.NotificationType;
import com.epay.merchant.validator.KeyValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Arrays;


/**
 * Class Name: MerchantService
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class KeyService {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(KeyService.class);
    private final KeyValidator keyValidator;
    private final KeyDao keyDao;
    private final PasswordGenerator passwordGenerator;

    /**
     * It will handle the key generation logic
     * MerchantResponse failure and save Login Audit details
     * @param keyGenerationRequest
     * @param type
     * @param response
     */
    public void generateKey(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        ByteArrayOutputStream pdfStream;
        // Step 1 : Validate the KMSKeyGenerationRequest
        keyValidator.validateKeyGenerationRequest(keyGenerationRequest);
        switch (type) {
            case API -> pdfStream = apiKeyGeneration(keyGenerationRequest);
            case ENCRYPTION -> pdfStream = encryptionKeyGeneration(keyGenerationRequest);
            default ->
                    throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "KeyType", "Valid Key Type are " + Arrays.toString(KeyType.values())));
        }
        fileResponse(type, keyGenerationRequest, response, pdfStream);
    }

    /**
     * It will validate the API key
     * @param apiKeyValidationRequest
     * @return  MerchantResponsee
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        keyValidator.validateAPIKeyValidationRequest(apiKeyValidationRequest);
        return keyDao.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * It will validate the MID and get the getEncryptionKeys
     * @param mId
     * @return  MerchantResponsee
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        keyValidator.validateMId(mId);
        return keyDao.getMerchantEncryptionKeys(mId);
    }
    /**
     * This method will generate the encryption Key
     * @param keyGenerationRequest
     * @return  ByteArrayOutputStream
     */
    private ByteArrayOutputStream encryptionKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        // Step 2 : Call the KMS APIs
        KMSEncryptionKeysResponse kmsEncryptionKeysResponse = keyDao.generateEncryptionKey(keyGenerationRequest);
        // Step 3 : Generate the Password-protected PDF File
        String password = passwordGenerator.generatePassword();
        ByteArrayOutputStream byteArrayOutputStream = PDFService.generatePDF(new EncryptionKeyPDFBuilder(), kmsEncryptionKeysResponse.getMek(), password);
        // Step 4 : Send Notification to Merchant
        // TODO : Send Notification over Email to Merchant
        keyDao.saveNotification(KeyType.ENCRYPTION, kmsEncryptionKeysResponse.getId(), "Encryption Key PDF file Password is :" + password, MerchantConstant.RESPONSE_SUCCESS, NotificationType.EMAIL);
        return byteArrayOutputStream;
    }

    /**
     * This method will generate the API Key and PDF
     * @param keyGenerationRequest
     * @return  ByteArrayOutputStream
     */
    private ByteArrayOutputStream apiKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        // Step 2 : Call the KMS APIs
        KMSAPIKeysResponse kmsapiKeysResponse = keyDao.generateApiKey(keyGenerationRequest.getMId());
        // Step 3 : Generate the Password-protected PDF File
        String password = passwordGenerator.generatePassword();
        ByteArrayOutputStream byteArrayOutputStream = PDFService.generatePDF(new APIKeyPDFBuilder(), kmsapiKeysResponse, password);
        // Step 4 : Send Notification to Merchant
        // TODO : Send Notification over Email to Merchant
        keyDao.saveNotification(KeyType.API, kmsapiKeysResponse.getId(), "API Key PDF File Password is :" + password, MerchantConstant.RESPONSE_SUCCESS, NotificationType.EMAIL);
        return byteArrayOutputStream;
    }
    /**
     * This method will fetch the keys associated with the given MID
     * @param keyType,mId,pageable
     * @return  KMSKeyResponse
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        return keyDao.getKeysByMerchant(keyType, mId, pageable);
    }

    /**
     * This method will create/update the file response
     * @param keyGenerationRequest,type,response, pdfStream
     */
    private void fileResponse(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response, ByteArrayOutputStream pdfStream) {
        try {
            HttpHeaders headers = new HttpHeaders();
            ContentDisposition contentDisposition = ContentDisposition.attachment().filename(type.name() + "_" + keyGenerationRequest.getMId() + "_" + System.currentTimeMillis() + ".pdf").build();
            headers.setContentDisposition(contentDisposition);
            response.setContentType(MediaType.APPLICATION_PDF_VALUE);
            response.setHeader(HttpHeaders.CONTENT_DISPOSITION, headers.getFirst(HttpHeaders.CONTENT_DISPOSITION));
            response.getOutputStream().write(pdfStream.toByteArray());
            response.getOutputStream().flush();
        } catch (IOException e) {
            logger.error("Error in PDF File Generation ", e);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, type.name() + "Key"));
        }
    }

}

package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.KmsClient;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.repository.KeyRepository;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.NotificationType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.Arrays;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class KeyDao {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(KeyDao.class);
    private final KmsClient kmsClient;
    private final KeyRepository keyRepository;
    private final MerchantConfig merchantConfig;
    private final NotificationDao notificationDao;
    private final MerchantInfoDao merchantInfoDao;

    /**
     * This method will handle generation API  Key logic
     * @param mId
     * @return  kmsapiKeysResponse
     */
    public KMSAPIKeysResponse generateApiKey(String mId) {
        try {
            MerchantResponse<KMSAPIKeysResponse> kmsResponse = kmsClient.generateAPIKeys(mId, merchantConfig.getApiKeyExpiryTime());
            if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_SUCCESS && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
                UUID keyId = saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_SUCCESS, "API Key Generated");
                KMSAPIKeysResponse kmsapiKeysResponse = kmsResponse.getData().getFirst();
                kmsapiKeysResponse.setId(keyId);
                return kmsapiKeysResponse;
            } else if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_FAILURE) {
                saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, Arrays.toString(kmsResponse.getErrors().toArray(new ErrorDto[0])));
                throw new ValidationException(kmsResponse.getErrors());
            }
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, "Error in API Key Generated");
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        } catch (Exception e) {
            log.error("Error in API Key Generation : ", e);
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, "Error in API Key Generated : " + e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        }
    }
    /**
     * This method will handle generation of encryption Key logic
     * @param keyGenerationRequest
     * @return  KMSEncryptionKeysResponse
     */
    public KMSEncryptionKeysResponse generateEncryptionKey(KeyGenerationRequest keyGenerationRequest) {
        try {
            MerchantResponse<String> kmsResponse = kmsClient.generateEncryptionKeys(keyGenerationRequest.getMId(), keyGenerationRequest.getOldKeyExpiryInHr(), merchantConfig.getEncryptionKeyExpiryTime());
            if (MerchantConstant.RESPONSE_SUCCESS == kmsResponse.getStatus() && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
                UUID keyId = saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_SUCCESS, "Encryption Key Generated");
                return KMSEncryptionKeysResponse.builder().id(keyId).mek(kmsResponse.getData().getFirst()).build();
            } else if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_FAILURE) {
                saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, Arrays.toString(kmsResponse.getErrors().toArray(new ErrorDto[0])));
                throw new ValidationException(kmsResponse.getErrors());
            }
            saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, "Error in Encryption Key Generated");
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        } catch (Exception e) {
            log.error("Error in Encryption Key Generation : ", e);
            saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, "Error in Encryption Key Generated : " + e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        }
    }
    /**
     * It will save the key generation notification type
     * @param notificationType
     * @param status
     * @param content
     * @param entityId
     * @param keyType
     */
    public void saveNotification(KeyType keyType, UUID entityId, String content, int status, NotificationType notificationType) {
        notificationDao.saveKeyGenerationNotification(keyType, entityId, content, status, notificationType);
    }

    /**
     * It will validate the API key if its exist and active or not
     * @param apiKeyValidationRequest
     * @return kmsResponse
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        MerchantResponse<String> kmsResponse = kmsClient.validatedMerchantKeys(apiKeyValidationRequest);
        if (MerchantConstant.RESPONSE_SUCCESS == kmsResponse.getStatus() && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
            String mId = kmsResponse.getData().getFirst();
            boolean isMIdExist = merchantInfoDao.isExistsByMIdAndStatus(mId, MerchantStatus.ACTIVE.name());
            if (isMIdExist) {
                return kmsResponse;
            }
            throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "Merchant", "MId : " + mId + " is not active."));
        }
        return kmsResponse;
    }
    /**
     * It will fetch the Merchant Encryption keys
     * @param mId
     * @return KMSEncryptionKeysResponse
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        return kmsClient.getEncryptionKeys(mId);
    }
    /**
     * It will fetch the keys mapped to MID
     * @param mId,keyType,pageable
     * @return KMSKeyResponse
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        return kmsClient.getKeysByMerchant(keyType, mId, pageable);
    }
    /**
     * It will save the key in DB
     * @param remark,status,keyType,mid
     */
    private UUID saveKey(String mid, KeyType keyType, int status, String remark) {
        KeyManagement keyManagement = KeyManagement.builder().mid(mid).keyType(keyType).status(status == 1).remarks(remark).build();
        return keyRepository.save(keyManagement).getId();
    }

}
package com.epay.merchant.validator;

import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.enums.MerchantStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;

@RequiredArgsConstructor
@Component
public class KeyValidator extends BaseValidator {

    private final MerchantInfoDao merchantInfoDao;

    /**
     * It will validate the key generation request.
     * MerchantResponse failure and save Login Audit details
     * @param keyGenerationRequest
     */
    public void validateKeyGenerationRequest(KeyGenerationRequest keyGenerationRequest) {
        errorDtoList = new ArrayList<>();
        validatedMandatoryField(keyGenerationRequest);
        validateMId(keyGenerationRequest.getMId());
    }
    /**
     * It will validate API key validation request
     * @param apiKeyValidationRequest
     */
    public void validateAPIKeyValidationRequest(APIKeyValidationRequest apiKeyValidationRequest) {
        errorDtoList = new ArrayList<>();
        validatedMandatoryField(apiKeyValidationRequest);
    }
    /**
     * It will validate the MId
     * @param mId
     */
    public void validateMId(String mId) {
        errorDtoList = new ArrayList<>();
        boolean existsByMIdAndStatus = merchantInfoDao.isExistsByMIdAndStatus(mId, MerchantStatus.ACTIVE.name());
        if (!existsByMIdAndStatus) {
            addError(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Valid MID"));
        }
        throwIfErrors();
    }
    /**
     * It will validate all the mandatory fields present in the request
     * @param keyGenerationRequest
     */
    private void validatedMandatoryField(KeyGenerationRequest keyGenerationRequest) {
        checkMandatoryField(keyGenerationRequest.getMId(), "MId");
        throwIfErrors();
    }
    /**
     * It will validate all the mandatory fields present in the request
     * @param apiKeyValidationRequest
     */
    private void validatedMandatoryField(APIKeyValidationRequest apiKeyValidationRequest) {
        checkMandatoryField(apiKeyValidationRequest.getApiKey(), "ApiKey");
        checkMandatoryField(apiKeyValidationRequest.getApiKeySecret(), "ApiKeySecret");
        throwIfErrors();
    }
}
