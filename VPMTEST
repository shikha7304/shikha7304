package com.epay.merchant.service;

import com.epay.merchant.dao.HelpSupportDao;
import com.epay.merchant.dto.HelpSupportTeamDto;
import com.epay.merchant.model.response.HelpSupportResponse;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.validator.HelpSupportValidator;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Class Name: HelpSupportService
 * *
 * Description:
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Service
@RequiredArgsConstructor
public class HelpSupportService {

    private final HelpSupportValidator helpSupportValidator;
    private final HelpSupportDao helpSupportDao;

    /**
     * Get Team information.
     * @return OnboardingDto
     */
    public MerchantResponse<HelpSupportResponse> getTeamsInfo(String mId) {
        //Step 1 : Get Active teams from DB.
        helpSupportValidator.validateCreateHelpSupportRequest(mId);
        List<HelpSupportResponse> teams = helpSupportDao.getTeam(mId);
        //Step 2 : Build MerchantResponse and return to caller
        return MerchantResponse.<HelpSupportResponse>builder().data(teams).status(MerchantConstant.RESPONSE_SUCCESS).count((long) teams.size()).build();
    }
    /**
     * Update Team information.
     * @param mId String
     * @param helpSupportTeamDto HelpSupportTeamDto
     * @return MerchantResponse
     */
    public MerchantResponse<HelpSupportResponse> updateTeam(String mId, HelpSupportTeamDto helpSupportTeamDto) {
        helpSupportTeamDto.setMId(mId);
        //Step 1 : HelpSupportValidator validation
        helpSupportValidator.validateUpdateHelpSupportRequest(helpSupportTeamDto);
        //Step 2 : Save the Merchant and Merchant User Data in DB
        HelpSupportResponse helpSupportResponses = helpSupportDao.updateTeam(helpSupportTeamDto);
        //Step 3 : Build MerchantResponse and return to caller
        return MerchantResponse.<HelpSupportResponse>builder().data(List.of(helpSupportResponses)).status(MerchantConstant.RESPONSE_SUCCESS).count(1L).build();
    }
}

package com.epay.merchant.dao;

import com.epay.merchant.dto.HelpSupportTeamDto;
import com.epay.merchant.entity.*;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.response.HelpSupportResponse;
import com.epay.merchant.repository.*;
import com.epay.merchant.util.DateTimeUtils;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.List;

import static com.epay.merchant.util.MerchantConstant.STATUS_ACTIVE;

/**
 * Class Name: HelpSupportDao
 * *
 * Description: DB layer logic for Help and Support
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class HelpSupportDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(HelpSupportDao.class);
    private final HelpSupportTeamRepository helpSupportTeamRepository;
    private final MerchantInfoRepository merchantInfoRepository;
    private final MerchantMapper mapper;

    /**
     * Creating Help and Support team records in database.
     * @return HelpSupportResponse
     */
    public List<HelpSupportResponse> getTeam(String mId) {
        List<HelpSupportTeam> helpSupportTeams = helpSupportTeamRepository.findByMid(mId);
        return helpSupportTeams.stream().map(mapper::mapHelpSupportTeamEntityToResponse).toList();
    }

    /**
     * Updating Help and Support team record in database.
     * @param helpSupportDto HelpSupportDto
     * @return HelpSupportResponse
     */
    @Transactional
    public HelpSupportResponse updateTeam(HelpSupportTeamDto helpSupportDto) {
        HelpSupportTeam helpSupportTeam = helpSupportTeamRepository.findByMidAndType(helpSupportDto.getMId(), helpSupportDto.getType())
                .orElse(new HelpSupportTeam());//TODO: do we need this to create if it is not present.
        helpSupportTeam.setValue(helpSupportDto.getValue());
        helpSupportTeam.setUpdatedAt(DateTimeUtils.getCurrentTimeInMills());
//        helpSupportTeam.setStatus(STATUS_ACTIVE);
//        EPayPrincipal ePayPrincipal = EPayIdentityUtil.getUserPrincipal();
//        helpSupportTeam.getUpdatedBy(ePayPrincipal.getUserId());
        helpSupportTeam = helpSupportTeamRepository.save(helpSupportTeam);
        log.info("Updated Help&Support: {}", helpSupportTeam);
        return mapper.mapHelpSupportTeamEntityToResponse(helpSupportTeam);
    }

    /**
     * Is MId exist in the system.
     * @param mId String
     * @return boolean
     */
    public boolean isExistsByMId(String mId) {
        return merchantInfoRepository.existsBymId(mId);
    }
}


package com.epay.merchant.validator;

import com.epay.merchant.dao.HelpSupportDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.HelpSupportTeamDto;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.HelpSupportType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;

/**
 * Class Name: HelpSupportValidator
 * *
 * Description: A validator class for user validation requests.
 * Extends the BaseValidator to provide common validation functionality.
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Component
@RequiredArgsConstructor
public class HelpSupportValidator extends BaseValidator {
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(HelpSupportValidator.class);
    private final HelpSupportDao helpSupportDao;
    /**
     * Validates the user validation request.
     * * @param helpSupportTeamDto the request object containing user details to be validated.
     */
    public void validateCreateHelpSupportRequest(String mId) {
        logger.debug("HelpSupport validation start for mId: {}", mId);
        errorDtoList = new ArrayList<>();
        checkMandatoryField(mId, "mId");
        validatedAlreadyPresent(mId);
        logger.debug("HelpSupport field validation completed for {}", mId);
    }
    public void validateUpdateHelpSupportRequest(HelpSupportTeamDto helpSupportTeamDto) {
        logger.debug("HelpSupport validation start for HelpSupportTeamDto: {}", helpSupportTeamDto);
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(helpSupportTeamDto);
        validateFieldsValue(helpSupportTeamDto);
        validatedAlreadyPresent(helpSupportTeamDto.getMId());
    }
    /**
     * Validates that all mandatory fields in the request are present.
     * * @param helpSupportTeamDto the request object containing user details to be validated.
     */
    private void validateMandatoryFields(HelpSupportTeamDto helpSupportTeamDto) {
        checkMandatoryField(helpSupportTeamDto.getMId(), "MId");
        checkMandatoryField(helpSupportTeamDto.getValue(), "Value");
        throwIfErrors();
    }
    /**
     * Validates the values of fields in the request object.
     * * @param helpSupportTeamDto the request object containing user details to be validated.
     */
    private void validateFieldsValue(HelpSupportTeamDto helpSupportTeamDto) {
        if(helpSupportTeamDto.getType() == HelpSupportType.EMAIL)
            validateFieldWithRegex(helpSupportTeamDto.getValue(), MerchantConstant.EMAIL_LENGTH, MerchantConstant.EMAIL_REGEX, "Email", "Please check {0} Format or Max length");
        if(helpSupportTeamDto.getType() == HelpSupportType.PHONE_NUMBER)
            validateFieldWithRegex(helpSupportTeamDto.getValue(), MerchantConstant.PHONE_REGEX, "Phone Number", "Please check Phone Number Format for {0}");
        throwIfErrors();
    }

    /**
     * validatedAlreadyPresent
     * @param mId String
     */
    void validatedAlreadyPresent(String mId) {
        if (!helpSupportDao.isExistsByMId(mId)) {
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MId")).build());
        }
        throwIfErrors();
    }
}


package com.epay.merchant.repository;

import com.epay.merchant.entity.HelpSupportTeam;
import com.epay.merchant.util.enums.HelpSupportType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Class Name: HelpSupportTeamRepository
 * *
 * Description:
 * *
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
public interface HelpSupportTeamRepository extends JpaRepository<HelpSupportTeam, UUID> {

    @Query("""
            SELECT hs
            FROM HelpSupportTeam hs
            LEFT JOIN MerchantInfo m
            ON hs.aggregatorId = m.aggregator WHERE m.mId = :mId
            """)
    List<HelpSupportTeam> findByMid(@Param("mId")String mId);

    @Query("""
            SELECT hs 
            FROM HelpSupportTeam hs 
            LEFT JOIN MerchantInfo m 
            ON hs.aggregatorId = m.aggregator WHERE m.mId = :mId AND hs.type = :type
            """)
    Optional<HelpSupportTeam> findByMidAndType(@Param("mId")String mId, @PathVariable("type") HelpSupportType type);

}


package com.epay.merchant.util.enums;

import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.util.ErrorConstants;

import java.text.MessageFormat;
import java.util.Arrays;

public enum HelpSupportType {
    PHONE_NUMBER, EMAIL;
    public static HelpSupportType getType(String type) {
        return Arrays.stream(values()).filter(r -> r.name().equalsIgnoreCase(type)).findFirst().orElseThrow(() -> new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "Type", "Valid HelpSupportType are " + Arrays.toString(HelpSupportType.values()))));
    }
}
public class MerchantConstant {
    public static final String ERROR_NEW_PASSWORD_SAME_AS_OLD = "The new password must be different from the old password.";
    public static final String ERROR_NEW_AND_CONFIRM_PASSWORD_MISMATCH = "The new password and confirmation password do not match.";
    public static final String ERROR_NEW_PASSWORD_REUSED = "The new password cannot be the same as any of the last five passwords.";
    public static final String STATUS_ACTIVE = "ACTIVE";
    public static final String PAGE_ACTIVE = "ACTIVE";
}







########

@ExtendWith(MockitoExtension.class)
public class HelpSupportServiceTest {

    @Mock
    private HelpSupportValidator helpSupportValidator;

    @Mock
    private HelpSupportDao helpSupportDao;

    @InjectMocks
    private HelpSupportService helpSupportService;

    @Test
    void testGetTeamsInfo_Success() {
        String mId = "test-mId";

        // Mock Data
        HelpSupportResponse team1 = new HelpSupportResponse();
        HelpSupportResponse team2 = new HelpSupportResponse();
        List<HelpSupportResponse> teams = List.of(team1, team2);

        // Mock behavior
        doNothing().when(helpSupportValidator).validateCreateHelpSupportRequest(mId);
        when(helpSupportDao.getTeam(mId)).thenReturn(teams);

        // Call service method
        MerchantResponse<HelpSupportResponse> response = helpSupportService.getTeamsInfo(mId);

        // Assertions
        assertNotNull(response);
        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        assertEquals(2, response.getCount());
        assertEquals(teams, response.getData());

        // Verify interactions
        verify(helpSupportValidator).validateCreateHelpSupportRequest(mId);
        verify(helpSupportDao).getTeam(mId);
    }

    @Test
    void testUpdateTeam_Success() {
        String mId = "test-mId";
        HelpSupportTeamDto teamDto = new HelpSupportTeamDto();
        teamDto.setMId(mId);
        teamDto.setType(HelpSupportType.EMAIL);
        teamDto.setValue("test@example.com");

        HelpSupportResponse updatedTeam = new HelpSupportResponse();

        // Mock behavior
        doNothing().when(helpSupportValidator).validateUpdateHelpSupportRequest(teamDto);
        when(helpSupportDao.updateTeam(teamDto)).thenReturn(updatedTeam);

        // Call service method
        MerchantResponse<HelpSupportResponse> response = helpSupportService.updateTeam(mId, teamDto);

        // Assertions
        assertNotNull(response);
        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        assertEquals(1, response.getCount());
        assertEquals(List.of(updatedTeam), response.getData());

        // Verify interactions
        verify(helpSupportValidator).validateUpdateHelpSupportRequest(teamDto);
        verify(helpSupportDao).updateTeam(teamDto);
    }

    @Test
    void testUpdateTeam_ValidationFailure() {
        String mId = "test-mId";
        HelpSupportTeamDto teamDto = new HelpSupportTeamDto();

        // Mock behavior
        doThrow(new IllegalArgumentException("Validation failed")).when(helpSupportValidator).validateUpdateHelpSupportRequest(teamDto);

        // Call service method and assert exception
        Exception exception = assertThrows(IllegalArgumentException.class, () -> helpSupportService.updateTeam(mId, teamDto));
        assertEquals("Validation failed", exception.getMessage());

        // Verify interactions
        verify(helpSupportValidator).validateUpdateHelpSupportRequest(teamDto);
        verifyNoInteractions(helpSupportDao);
    }
}







@ExtendWith(MockitoExtension.class)
public class HelpSupportValidatorTest {

    @Mock
    private HelpSupportDao helpSupportDao;

    @InjectMocks
    private HelpSupportValidator helpSupportValidator;

    @Test
    void testValidateCreateHelpSupportRequest_Success() {
        String mId = "valid-mId";

        // Mock behavior
        when(helpSupportDao.isExistsByMId(mId)).thenReturn(true);

        // Call validation method
        assertDoesNotThrow(() -> helpSupportValidator.validateCreateHelpSupportRequest(mId));

        // Verify interactions
        verify(helpSupportDao).isExistsByMId(mId);
    }

    @Test
    void testValidateCreateHelpSupportRequest_MIdNotFound() {
        String mId = "invalid-mId";

        // Mock behavior
        when(helpSupportDao.isExistsByMId(mId)).thenReturn(false);

        // Call validation method and assert exception
        Exception exception = assertThrows(IllegalArgumentException.class, () -> helpSupportValidator.validateCreateHelpSupportRequest(mId));
        assertTrue(exception.getMessage().contains("MId"));

        // Verify interactions
        verify(helpSupportDao).isExistsByMId(mId);
    }

    @Test
    void testValidateUpdateHelpSupportRequest_Success() {
        HelpSupportTeamDto teamDto = new HelpSupportTeamDto();
        teamDto.setMId("valid-mId");
        teamDto.setType(HelpSupportType.EMAIL);
        teamDto.setValue("test@example.com");

        // Mock behavior
        when(helpSupportDao.isExistsByMId(teamDto.getMId())).thenReturn(true);

        // Call validation method
        assertDoesNotThrow(() -> helpSupportValidator.validateUpdateHelpSupportRequest(teamDto));

        // Verify interactions
        verify(helpSupportDao).isExistsByMId(teamDto.getMId());
    }

    @Test
    void testValidateUpdateHelpSupportRequest_InvalidEmailFormat() {
        HelpSupportTeamDto teamDto = new HelpSupportTeamDto();
        teamDto.setMId("valid-mId");
        teamDto.setType(HelpSupportType.EMAIL);
        teamDto.setValue("invalid-email");

        // Mock behavior
        when(helpSupportDao.isExistsByMId(teamDto.getMId())).thenReturn(true);

        // Call validation method and assert exception
        Exception exception = assertThrows(IllegalArgumentException.class, () -> helpSupportValidator.validateUpdateHelpSupportRequest(teamDto));
        assertTrue(exception.getMessage().contains("Email"));

        // Verify interactions
        verify(helpSupportDao).isExistsByMId(teamDto.getMId());
    }
}
