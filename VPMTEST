  @GetMapping("/profile/{UserName}")
    @Operation(summary = "Get Merchant User Profile details.", description = "Get Logged in user profile and view details ")
    public MerchantResponse<UserProfileResponse> getProfileResponse(@PathVariable String UserName) {
        // TODO UserName Need to get from SecurityContext
        return merchantUserService.getProfileResponse(UserName);
    }

public class MerchantUserService {

    private final MerchantInfoDao merchantInfoDao;
    private final MerchantUserDao merchantUserDao;
    private final MerchantMapper merchantMapper;

    LoggerUtility log = LoggerFactoryUtility.getLogger(ValidationController.class);

    /**
 public MerchantResponse<UserProfileResponse> getProfileResponse(String userName) {

        // Step 1 : Get User Name from Security Context
        // TODO UserName Need to get from SecurityContext jwtService

        // Step 2 : Get Merchant User Info of Logged in Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.findByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName);

        // Step 3 : convert DTO to UserProfileResponse
        UserProfileResponse userProfileResponse = merchantUserDao.mapMerchantUserDtoToResponse(merchantUserDto);

        // Step 4 : Building the response
        return MerchantResponse.<UserProfileResponse>builder().status(MerchantConstant.RESPONSE_SUCCESS).data(List.of(userProfileResponse)).count(1L).total(1L).build();
    }


@Test
    void testGetAllAccessMerchantInfoEmptyResult() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<MerchantInfoDto> emptyPage = Page.empty();

        when(merchantInfoDao.getALl(pageable)).thenReturn(emptyPage);
        when(merchantMapper.mapMerchantInfoDTOListToResponseList(Collections.emptyList())).thenReturn(Collections.emptyList());

        MerchantResponse<MerchantInfoResponse> result = merchantUserService.getAllAccessMerchantInfo("userName", pageable);

        assertNotNull(result);
        assertEquals(MerchantConstant.RESPONSE_SUCCESS, result.getStatus());
        assertEquals(0, result.getCount());
        assertEquals(0, result.getTotal());
        assertEquals(Collections.emptyList(), result.getData());

        verify(merchantInfoDao, times(1)).getALl(pageable);
        verify(merchantMapper, times(1)).mapMerchantInfoDTOListToResponseList(Collections.emptyList());
    }

 public MerchantUserDto findByUserNameOrEmailOrMobilePhoneAndStatus(String userName, String email, String phone) {
        MerchantUser merchantUser = merchantUserRepository.findByUserNameOrEmailOrMobilePhoneAndStatus(userName, email, phone, UserStatus.ACTIVE.name()).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName")));
        return merchantMapper.mapMerchantUserEntityToDto(merchantUser);
    }


 public UserProfileResponse mapMerchantUserDtoToResponse(MerchantUserDto merchantUserDto){
        UserProfileResponse userProfileResponse = merchantMapper.mapMerchantUserDtoToResponse(merchantUserDto);
        userProfileResponse.setRoleName(merchantUserRepository.findUserRoleByUserId(merchantUserDto.getId()));
        return userProfileResponse;
    }


public class UserProfileResponse {

    private String userName;
    private String firstName;
    private String middleName;
    private String lastName;
    private String email;
    private String mobilePhone;
    private String roleName;
    private Long createdAt;
    private UserStatus status;

}

    @Test
    void testGetProfileResponse_Success(){
        String userName = "testUser";
        MerchantUserDto mockMerchantUserDto = new MerchantUserDto();
        UserProfileResponse mockUserProfileResponse = new UserProfileResponse();

        when(merchantUserDao.findByUserNameOrEmailOrMobilePhone(userName, userName, userName)).thenReturn(mockMerchantUserDto);
        when(merchantMapper.mapMerchantUserDtoToResponse(mockMerchantUserDto)).thenReturn(mockUserProfileResponse);
        MerchantResponse<UserProfileResponse> response = merchantUserService.getProfileResponse(userName);

        assertNotNull(response);
        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        assertEquals(1L, response.getCount());
        assertEquals(1L, response.getTotal());
        assertFalse(ObjectUtils.isEmpty(response.getData()));
        assertEquals(mockUserProfileResponse, response.getData().get(0));

        verify(merchantUserDao, times(1)).findByUserNameOrEmailOrMobilePhone(userName, userName, userName);
        verify(merchantMapper, times(1)).mapMerchantUserDtoToResponse(mockMerchantUserDto);

    }

    @Test
    void testGetProfileResponse_UserNotFound() {
        String userName = "";

        when(merchantUserDao.findByUserNameOrEmailOrMobilePhone(userName, userName, userName)).thenReturn(null);
        when(merchantUserDao.mapMerchantUserDtoToResponse(merchantUserDto)).thenReturn(any());
        MerchantException exception = assertThrows(MerchantException.class, () -> merchantUserService.getProfileResponse(userName));

        assertEquals(ErrorConstants.NOT_FOUND_ERROR_CODE, exception.getErrorCode());
        assertTrue(exception.getMessage().contains("UserName"));

        verify(merchantUserDao, times(1)).findByUserNameOrEmailOrMobilePhone(userName, userName, userName);
        verifyNoInteractions(merchantMapper);
    }





import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.util.ObjectUtils;

public class MerchantUserServiceTest {

    @Mock
    private MerchantUserDao merchantUserDao;

    @Mock
    private MerchantMapper merchantMapper;

    @InjectMocks
    private MerchantUserService merchantUserService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testGetProfileResponse_Success() {
        // Arrange
        String userName = "testUser";
        MerchantUserDto mockMerchantUserDto = new MerchantUserDto();
        UserProfileResponse mockUserProfileResponse = new UserProfileResponse();

        when(merchantUserDao.findByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName))
            .thenReturn(mockMerchantUserDto);
        when(merchantUserDao.mapMerchantUserDtoToResponse(mockMerchantUserDto))
            .thenReturn(mockUserProfileResponse);

        // Act
        MerchantResponse<UserProfileResponse> response = merchantUserService.getProfileResponse(userName);

        // Assert
        assertNotNull(response);
        assertEquals(MerchantConstant.RESPONSE_SUCCESS, response.getStatus());
        assertEquals(1L, response.getCount());
        assertEquals(1L, response.getTotal());
        assertFalse(ObjectUtils.isEmpty(response.getData()));
        assertEquals(mockUserProfileResponse, response.getData().get(0));

        // Verify
        verify(merchantUserDao, times(1)).findByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName);
        verify(merchantUserDao, times(1)).mapMerchantUserDtoToResponse(mockMerchantUserDto);
    }

    @Test
    void testGetProfileResponse_UserNotFound() {
        // Arrange
        String userName = "nonExistentUser";

        when(merchantUserDao.findByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName))
            .thenThrow(new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE,
                MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "UserName")));

        // Act & Assert
        MerchantException exception = assertThrows(MerchantException.class, 
            () -> merchantUserService.getProfileResponse(userName));

        assertEquals(ErrorConstants.NOT_FOUND_ERROR_CODE, exception.getErrorCode());
        assertTrue(exception.getMessage().contains("UserName"));

        // Verify
        verify(merchantUserDao, times(1)).findByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName);
        verifyNoInteractions(merchantMapper);
    }
}




public UUID save(OtpGenerationDto otpGenerationDto) {
        MerchantUserDto merchantUser = merchantUserDao.findByUserNameOrEmailOrMobilePhoneAndStatus(otpGenerationDto.getUserName(), otpGenerationDto.getUserName(), otpGenerationDto.getUserName(), UserStatus.ACTIVE);
        OtpManagement otpManagement = otpManagementMapper.mapOtpGenerationDtoToOtpManagement(otpGenerationDto);
        otpManagement.setUserId(merchantUser.getId());
        otpManagement = otpManagementRepository.save(otpManagement);
        return otpManagement.getId();
    }


@Test
    void TestSave() {

        MerchantUser merchantUserDto = MerchantUser.builder()
                .id(UUID.randomUUID())
                .city("mumbai")
                .build();
        OtpManagement otpManagement = new OtpManagement();
        MerchantUser merchantUser = new MerchantUser();
        merchantUser.setUserName("userName");
        otpManagement.setId(UUID.fromString("d149657e-0af5-497a-a70e-289a8cb2f46d"));
        otpManagement.setUserId(UUID.randomUUID());
        OtpGenerationDto otpGenerationDto = OtpGenerationDto.builder()
                        .otpCode("1234")

                                .build();

        when(merchantUserRepository.findByUserNameOrEmailOrMobilePhoneAndStatus(otpGenerationDto.getUserName(), otpGenerationDto.getUserName(), otpGenerationDto.getUserName(), UserStatus.ACTIVE)).thenReturn(Optional.of(merchantUser));
        when(otpManagementMapper.mapOtpGenerationDtoToOtpManagement(otpGenerationDto)).thenReturn(otpManagement);
        when(otpManagementRepository.save(otpManagement)).thenReturn(otpManagement);
        when(merchantUserDao.findByUserNameOrEmailOrMobilePhoneAndStatus("userName", "userName", "userName",UserStatus.ACTIVE)).thenReturn(merchantUserDto);
        UUID result= otpManagementDao.save(otpGenerationDto);
        assertEquals(result, otpManagement.getId());

    }
