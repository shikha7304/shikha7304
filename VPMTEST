Hereâ€™s the updated method-level documentation for the NotificationDao class and other related methods from the provided code:

Method-Level Comments

sendEmailNotification

/**
 * Sends an email notification to the specified recipient and logs the notification details.
 *
 * @param merchantEmailDto       The email details, including content and recipient address.
 * @param notificationManagement The notification entity to log the email sending activity.
 */
public void sendEmailNotification(MerchantEmailDto merchantEmailDto, NotificationManagement notificationManagement) {

sendSmsNotification

/**
 * Sends an SMS notification to the specified recipient and logs the notification details.
 *
 * @param smsRequest             The SMS details, including the recipient's mobile number and message content.
 * @param notificationManagement The notification entity to log the SMS sending activity.
 */
public void sendSmsNotification(SmsRequest smsRequest, NotificationManagement notificationManagement) {

sendEmail

/**
 * Asynchronously sends an email notification using the provided email details.
 * Handles exceptions during email delivery and updates the response status.
 *
 * @param merchantEmailDto The email details, including content and recipient address.
 */
private void sendEmail(MerchantEmailDto merchantEmailDto) {

sendSMS

/**
 * Asynchronously sends an SMS notification using the provided SMS details.
 * Handles exceptions during SMS delivery and updates the response status.
 *
 * @param smsRequest The SMS details, including the recipient's mobile number and message content.
 */
private void sendSMS(SmsRequest smsRequest) {

getEmailDto

/**
 * Constructs an EmailDto object using the provided merchant email details.
 * Supports custom recipient and CC configurations.
 *
 * @param merchantEmailDto The merchant email details, including content and type.
 * @return EmailDto The constructed email object to be sent.
 */
private EmailDto getEmailDto(MerchantEmailDto merchantEmailDto) {

sendOtpGenerationNotification

/**
 * Sends an OTP notification via email and SMS to the specified merchant user.
 *
 * @param otpManagement The OTP management entity containing request details.
 * @param merchantUser  The merchant user to whom the OTP is sent.
 * @param otp           The generated OTP code.
 */
private void sendOtpGenerationNotification(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {

sendEmail (for OTP)

/**
 * Sends an OTP notification via email to the specified merchant user.
 * Logs the email activity in the notification management entity.
 *
 * @param otpManagement The OTP management entity containing request details.
 * @param merchantUser  The merchant user to whom the email is sent.
 * @param otp           The generated OTP code.
 */
private void sendEmail(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {

sendSms (for OTP)

/**
 * Sends an OTP notification via SMS to the specified merchant user.
 * Logs the SMS activity in the notification management entity.
 *
 * @param otpManagement The OTP management entity containing request details.
 * @param merchantUser  The merchant user to whom the SMS is sent.
 * @param otp           The generated OTP code.
 */
private void sendSms(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {

validateRequestIdByUserNameAndRequestType

/**
 * Validates the OTP request ID for a specific user and request type.
 * Ensures the OTP has not expired, is verified, and matches the provided request ID.
 *
 * @param requestId  The OTP request ID to validate.
 * @param userName   The username associated with the OTP request.
 * @param requestType The type of the OTP request (e.g., password reset, login).
 * @throws MerchantException If the OTP is invalid, expired, or verification fails.
 */
public void validateRequestIdByUserNameAndRequestType(String requestId, String userName, RequestType requestType) {

sendNotification

/**
 * Sends a notification (email and SMS) to the merchant user for password generation or reset.
 *
 * @param requestType The type of request (e.g., password reset or change).
 * @param entityId    The entity ID associated with the request.
 * @param merchantUser The merchant user to whom the notification is sent.
 * @param password    The generated or updated password.
 */
private void sendNotification(RequestType requestType, UUID entityId, MerchantUserDto merchantUser, String password) {

sendEmail (for Password Notification)

/**
 * Sends a password notification via email to the specified merchant user.
 *
 * @param requestType The type of request (e.g., password reset or change).
 * @param merchantUser The merchant user to whom the email is sent.
 * @param password    The generated or updated password.
 * @param entityId    The entity ID associated with the request.
 */
private void sendEmail(RequestType requestType, MerchantUserDto merchantUser, String password, UUID entityId) {

sendSms (for Password Notification)

/**
 * Sends a password notification via SMS to the specified merchant user.
 *
 * @param requestType The type of request (e.g., password reset or change).
 * @param merchantUser The merchant user to whom the SMS is sent.
 * @param entityId    The entity ID associated with the request.
 */
private void sendSms(RequestType requestType, MerchantUserDto merchantUser, UUID entityId) {

buildNotificationManagement

/**
 * Constructs a NotificationManagement entity for logging notification activities.
 *
 * @param requestType The type of the notification request.
 * @param entityId    The entity ID associated with the notification.
 * @return NotificationManagement The constructed notification management entity.
 */
private static NotificationManagement buildNotificationManagement(RequestType requestType, UUID entityId) {

Let me know if additional adjustments are needed!



package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.MerchantEmailDto;
import com.epay.merchant.entity.NotificationManagement;
import com.epay.merchant.dto.SmsRequest;
import com.epay.merchant.repository.NotificationManagementRepository;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.NotificationType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import com.sbi.epay.notification.exception.NotificationException;
import com.sbi.epay.notification.model.EmailDto;
import com.sbi.epay.notification.model.SmsDto;
import com.sbi.epay.notification.service.EmailService;
import com.sbi.epay.notification.service.SmsService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;

@Component
@RequiredArgsConstructor
public class NotificationDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final EmailService emailService;
    private final SmsService smsService;
    private final MerchantConfig merchantConfig;
    private final NotificationManagementRepository notificationManagementRepository;
    private int emailResponse = MerchantConstant.RESPONSE_SUCCESS;
    private int smsResponse = MerchantConstant.RESPONSE_SUCCESS;

    public void sendEmailNotification(MerchantEmailDto merchantEmailDto, NotificationManagement notificationManagement) {
        sendEmail(merchantEmailDto);
        notificationManagement.setNotificationType(NotificationType.EMAIL);
        notificationManagement.setContent(merchantEmailDto.getContent().toString());
        notificationManagement.setStatus(emailResponse);
        notificationManagementRepository.save(notificationManagement);
    }

    public void sendSmsNotification(SmsRequest smsRequest, NotificationManagement notificationManagement) {
        sendSMS(smsRequest);
        notificationManagement.setNotificationType(NotificationType.SMS);
        notificationManagement.setContent(smsRequest.getMessage());
        notificationManagement.setStatus(smsResponse);
        notificationManagementRepository.save(notificationManagement);
    }

    /**
     * Sending email.
     */
    private void sendEmail(MerchantEmailDto merchantEmailDto) {
        CompletableFuture.runAsync(() -> {
            try {
                EmailDto emailDto = getEmailDto(merchantEmailDto);
                emailService.sendEmail(emailDto);
            } catch (NotificationException n) {
                log.error("Error in send Email, merchantEmailDto {}", merchantEmailDto, n);
                emailResponse = MerchantConstant.RESPONSE_FAILURE;
            } catch (Exception e) {
                log.error("Error in send Email, merchantEmailDto {}", merchantEmailDto, e.getMessage());
                emailResponse = MerchantConstant.RESPONSE_FAILURE;
            }
        });
    }

    private void sendSMS(SmsRequest smsRequest) {
        CompletableFuture.runAsync(() -> {
            try {
                SmsDto smsDto = SmsDto.builder().mobileNumber(smsRequest.getMobileNumber()).message(smsRequest.getMessage()).build();
                smsService.sendSMS(smsDto);
            } catch (NotificationException n) {
                log.error("Error in send SMS, smsRequest {}", smsRequest, n);
                smsResponse = MerchantConstant.RESPONSE_FAILURE;
            } catch (Exception e) {
                log.error("Error in send SMS, smsRequest {}", smsRequest, e.getMessage());
                smsResponse = MerchantConstant.RESPONSE_FAILURE;
            }
        });
    }

    private EmailDto getEmailDto(MerchantEmailDto merchantEmailDto) {
        EmailDto emailDto = EmailDto.builder()
                .subject(merchantEmailDto.getEMailType().getSubjectName())
                .from(merchantConfig.getFrom())
                .body(merchantEmailDto.getContent())
                .emailTemplate(merchantEmailDto.getEMailType().getTemplateName()).build();
        if (!merchantConfig.getRecipient().isEmpty()) {
            emailDto.setRecipient(merchantConfig.getRecipient());
            emailDto.setCc(merchantEmailDto.getToEmail());
        } else {
            emailDto.setRecipient(merchantEmailDto.getToEmail());
        }
        return emailDto;
    }
}




    private void sendOtpGenerationNotification(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {
        sendEmail(otpManagement, merchantUser, otp);
        sendSms(otpManagement, merchantUser, otp);
    }

    private void sendEmail(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {
        NotificationManagement notificationMgmt = buildNotificationManagement(otpManagement);
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder().toEmail(merchantUser.getEmail()).content(EmailUtil.generateOtpContent(merchantUser, otp)).eMailType(EmailUtil.getEMailType(otpManagement.getRequestType())).build();
        notificationDao.sendEmailNotification(merchantEmailDto, notificationMgmt);
    }

    private void sendSms(OtpManagement otpManagement, MerchantUserDto merchantUser, String otp) {
        NotificationManagement notificationMgmt = buildNotificationManagement(otpManagement);
        SmsRequest smsRequest = SmsRequest.builder().mobileNumber(merchantUser.getMobilePhone()).message(MessageFormat.format(SmsUtil.getSMSTemplate(otpManagement.getRequestType()), otp, merchantConfig.getOtpExpiryTime())).build();
        notificationDao.sendSmsNotification(smsRequest, notificationMgmt);
    }

    public void validateRequestIdByUserNameAndRequestType(String requestId, String userName, RequestType requestType) {
        MerchantUserDto merchantUser = getMerchantUserDto(userName, requestType);
        OtpManagement otpManagement = otpManagementRepository.findTopByRequestTypeAndUserIdOrderByExpiryTimeDesc(requestType, merchantUser.getId()).orElseThrow(() -> new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "OTP Verification", "OTP Verification Fail")));
        if (otpManagement.getRequestId().toString().equals(requestId) && otpManagement.isVerified() && !DateTimeUtils.isPastDate(otpManagement.getExpiryTime())) {
            return;
        }
        throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "OTP Verification", "OTP Verification Fail, Please try again"));
    }
}



/**
     * This method will send password notification to user
     * @param  requestType RequestType
     * @param entityId UUID,
     * @param password String
     */
    private void sendNotification(RequestType requestType, UUID entityId, MerchantUserDto merchantUser, String password) {
        sendSms(requestType, merchantUser, entityId);
        sendEmail(requestType, merchantUser, password, entityId);
    }

    private void sendEmail(RequestType requestType, MerchantUserDto merchantUser, String password, UUID entityId) {
        NotificationManagement notificationMgmt = buildNotificationManagement(requestType, entityId);
        String text = RequestType.CHANGE_PASSWORD.equals(requestType) ? "changed" : "reset";
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder().toEmail(merchantUser.getEmail()).content(EmailUtil.generateDefaultContent(MessageFormat.format("Password has been {0} successfully, {1} password is {2}", text, text, password))).eMailType(EMailType.PASSWORD_GENERATION).build();
        notificationDao.sendEmailNotification(merchantEmailDto, notificationMgmt);
    }

    private void sendSms(RequestType requestType, MerchantUserDto merchantUser, UUID entityId) {
        NotificationManagement notificationMgmt = buildNotificationManagement(requestType, entityId);
        SmsRequest smsRequest = SmsRequest.builder().mobileNumber(merchantUser.getMobilePhone()).message(SmsUtil.USER_PASSWORD_REGENERATION_REQUEST).build();
        notificationDao.sendSmsNotification(smsRequest, notificationMgmt);
    }

    private static NotificationManagement buildNotificationManagement(RequestType requestType, UUID entityId) {
        return NotificationManagement.builder().requestType(requestType.getName()).entityId(entityId).entityName(NotificationEntityType.PASSWORD_MANAGEMENT).build();
    }

}
