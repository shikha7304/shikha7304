package com.epay.merchant.controller;

import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.service.KeyService;
import com.epay.merchant.util.enums.KeyType;
import io.swagger.v3.oas.annotations.Operation;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;


/**
 * Class Name: MerchantController
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@RestController
@RequiredArgsConstructor
@RequestMapping("/key")
@Validated
public class KeyController {

    private final KeyService keyService;

    /**
     * Generate Key
     * @param type KeyType
     * @param keyGenerationRequest KeyGenerationRequest
     * @param response HttpServletResponse
     */
    @PostMapping("/generation/{type}")
    @Operation(summary = "Generate the API and Encryption Key for a Merchant.", description = "Generate the API and Encryption Key for a Merchant.")
    public void generateKey(@PathVariable("type") KeyType type, @RequestBody KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        keyService.generateKey(type, keyGenerationRequest, response);
    }

    /**
     * Validated API Key
     * @param apiKeyValidationRequest APIKeyValidationRequest
     * @return MerchantResponse
     */
    @PostMapping("/validated/api")
    @Operation(summary = "Validate API Keys for Given MID", description = "Validate API Keys for Given MID")
    public MerchantResponse<String> validatedAPIKey(@RequestBody @Valid APIKeyValidationRequest apiKeyValidationRequest) {
        return keyService.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * Get Merchant Encryption Keys
     * @param mId String
     * @return MerchantResponse
     */
    @GetMapping("/encryption/{mId}")
    @Operation(summary = "Get Encryption Keys for Given MID", description = "Get Encryption Keys for Given MID")
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(@PathVariable String mId) {
        return keyService.getMerchantEncryptionKeys(mId);
    }

    /**
     * Get Keys By Merchant
     * @param keyType KeyType
     * @param mId String
     * @param pageable Pageable
     * @return MerchantResponse
     */
    @GetMapping("/{mId}/{keyType}")
    @Operation(summary = "Get list of keys for given MID", description = "Get list of keys for given MID")
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(@PathVariable("keyType") KeyType keyType, @PathVariable("mId") String mId,  @PageableDefault(size = 50, page = 0) Pageable pageable) {
        return keyService.getKeysByMerchant(keyType, mId, pageable);
    }


}
package com.epay.merchant.service;

import com.epay.merchant.dao.KeyDao;
import com.epay.merchant.document.pdf.APIKeyPDFBuilder;
import com.epay.merchant.document.pdf.EncryptionKeyPDFBuilder;
import com.epay.merchant.document.pdf.PDFService;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.PasswordGenerator;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.NotificationType;
import com.epay.merchant.validator.KeyValidator;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Arrays;


/**
 * Class Name: MerchantService
 * *
 * Description:
 * *
 * Author: V1017903(bhushan wadekar)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

@Service
@RequiredArgsConstructor
public class KeyService {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(KeyService.class);
    private final KeyValidator keyValidator;
    private final KeyDao keyDao;
    private final PasswordGenerator passwordGenerator;

    /**
     * It will handle the key generation logic
     * MerchantResponse failure and save Login Audit details
     * @param keyGenerationRequest
     * @param type
     * @param response
     */
    public void generateKey(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response) {
        ByteArrayOutputStream pdfStream;
        // Step 1 : Validate the KMSKeyGenerationRequest
        keyValidator.validateKeyGenerationRequest(keyGenerationRequest);
        switch (type) {
            case API -> pdfStream = apiKeyGeneration(keyGenerationRequest);
            case ENCRYPTION -> pdfStream = encryptionKeyGeneration(keyGenerationRequest);
            default ->
                    throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "KeyType", "Valid Key Type are " + Arrays.toString(KeyType.values())));
        }
        fileResponse(type, keyGenerationRequest, response, pdfStream);
    }

    /**
     * It will validate the API key
     * @param apiKeyValidationRequest
     * @return  MerchantResponsee
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        keyValidator.validateAPIKeyValidationRequest(apiKeyValidationRequest);
        return keyDao.validatedAPIKey(apiKeyValidationRequest);
    }

    /**
     * It will validate the MID and get the getEncryptionKeys
     * @param mId
     * @return  MerchantResponsee
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        keyValidator.validateMId(mId);
        return keyDao.getMerchantEncryptionKeys(mId);
    }
    /**
     * This method will generate the encryption Key
     * @param keyGenerationRequest
     * @return  ByteArrayOutputStream
     */
    private ByteArrayOutputStream encryptionKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        // Step 2 : Call the KMS APIs
        KMSEncryptionKeysResponse kmsEncryptionKeysResponse = keyDao.generateEncryptionKey(keyGenerationRequest);
        // Step 3 : Generate the Password-protected PDF File
        String password = passwordGenerator.generatePassword();
        ByteArrayOutputStream byteArrayOutputStream = PDFService.generatePDF(new EncryptionKeyPDFBuilder(), kmsEncryptionKeysResponse.getMek(), password);
        // Step 4 : Send Notification to Merchant
        // TODO : Send Notification over Email to Merchant
        keyDao.saveNotification(KeyType.ENCRYPTION, kmsEncryptionKeysResponse.getId(), "Encryption Key PDF file Password is :" + password, MerchantConstant.RESPONSE_SUCCESS, NotificationType.EMAIL);
        return byteArrayOutputStream;
    }

    /**
     * This method will generate the API Key and PDF
     * @param keyGenerationRequest
     * @return  ByteArrayOutputStream
     */
    private ByteArrayOutputStream apiKeyGeneration(KeyGenerationRequest keyGenerationRequest) {
        // Step 2 : Call the KMS APIs
        KMSAPIKeysResponse kmsapiKeysResponse = keyDao.generateApiKey(keyGenerationRequest.getMId());
        // Step 3 : Generate the Password-protected PDF File
        String password = passwordGenerator.generatePassword();
        ByteArrayOutputStream byteArrayOutputStream = PDFService.generatePDF(new APIKeyPDFBuilder(), kmsapiKeysResponse, password);
        // Step 4 : Send Notification to Merchant
        // TODO : Send Notification over Email to Merchant
        keyDao.saveNotification(KeyType.API, kmsapiKeysResponse.getId(), "API Key PDF File Password is :" + password, MerchantConstant.RESPONSE_SUCCESS, NotificationType.EMAIL);
        return byteArrayOutputStream;
    }
    /**
     * This method will fetch the keys associated with the given MID
     * @param keyType,mId,pageable
     * @return  KMSKeyResponse
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        return keyDao.getKeysByMerchant(keyType, mId, pageable);
    }

    /**
     * This method will create/update the file response
     * @param keyGenerationRequest,type,response, pdfStream
     */
    private void fileResponse(KeyType type, KeyGenerationRequest keyGenerationRequest, HttpServletResponse response, ByteArrayOutputStream pdfStream) {
        try {
            HttpHeaders headers = new HttpHeaders();
            ContentDisposition contentDisposition = ContentDisposition.attachment().filename(type.name() + "_" + keyGenerationRequest.getMId() + "_" + System.currentTimeMillis() + ".pdf").build();
            headers.setContentDisposition(contentDisposition);
            response.setContentType(MediaType.APPLICATION_PDF_VALUE);
            response.setHeader(HttpHeaders.CONTENT_DISPOSITION, headers.getFirst(HttpHeaders.CONTENT_DISPOSITION));
            response.getOutputStream().write(pdfStream.toByteArray());
            response.getOutputStream().flush();
        } catch (IOException e) {
            logger.error("Error in PDF File Generation ", e);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, type.name() + "Key"));
        }
    }

}

package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.KmsClient;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.repository.KeyRepository;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.NotificationType;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.Arrays;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class KeyDao {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(KeyDao.class);
    private final KmsClient kmsClient;
    private final KeyRepository keyRepository;
    private final MerchantConfig merchantConfig;
    private final NotificationDao notificationDao;
    private final MerchantInfoDao merchantInfoDao;

    /**
     * This method will handle generation API  Key logic
     * @param mId
     * @return  kmsapiKeysResponse
     */
    public KMSAPIKeysResponse generateApiKey(String mId) {
        try {
            MerchantResponse<KMSAPIKeysResponse> kmsResponse = kmsClient.generateAPIKeys(mId, merchantConfig.getApiKeyExpiryTime());
            if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_SUCCESS && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
                UUID keyId = saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_SUCCESS, "API Key Generated");
                KMSAPIKeysResponse kmsapiKeysResponse = kmsResponse.getData().getFirst();
                kmsapiKeysResponse.setId(keyId);
                return kmsapiKeysResponse;
            } else if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_FAILURE) {
                saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, Arrays.toString(kmsResponse.getErrors().toArray(new ErrorDto[0])));
                throw new ValidationException(kmsResponse.getErrors());
            }
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, "Error in API Key Generated");
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        } catch (Exception e) {
            log.error("Error in API Key Generation : ", e);
            saveKey(mId, KeyType.API, MerchantConstant.RESPONSE_FAILURE, "Error in API Key Generated : " + e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        }
    }
    /**
     * This method will handle generation of encryption Key logic
     * @param keyGenerationRequest
     * @return  KMSEncryptionKeysResponse
     */
    public KMSEncryptionKeysResponse generateEncryptionKey(KeyGenerationRequest keyGenerationRequest) {
        try {
            MerchantResponse<String> kmsResponse = kmsClient.generateEncryptionKeys(keyGenerationRequest.getMId(), keyGenerationRequest.getOldKeyExpiryInHr(), merchantConfig.getEncryptionKeyExpiryTime());
            if (MerchantConstant.RESPONSE_SUCCESS == kmsResponse.getStatus() && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
                UUID keyId = saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_SUCCESS, "Encryption Key Generated");
                return KMSEncryptionKeysResponse.builder().id(keyId).mek(kmsResponse.getData().getFirst()).build();
            } else if (kmsResponse.getStatus() == MerchantConstant.RESPONSE_FAILURE) {
                saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, Arrays.toString(kmsResponse.getErrors().toArray(new ErrorDto[0])));
                throw new ValidationException(kmsResponse.getErrors());
            }
            saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, "Error in Encryption Key Generated");
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        } catch (Exception e) {
            log.error("Error in Encryption Key Generation : ", e);
            saveKey(keyGenerationRequest.getMId(), KeyType.ENCRYPTION, MerchantConstant.RESPONSE_FAILURE, "Error in Encryption Key Generated : " + e.getMessage());
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE, MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, "API Key"));
        }
    }
    /**
     * It will save the key generation notification type
     * @param notificationType
     * @param status
     * @param content
     * @param entityId
     * @param keyType
     */
    public void saveNotification(KeyType keyType, UUID entityId, String content, int status, NotificationType notificationType) {
        notificationDao.saveKeyGenerationNotification(keyType, entityId, content, status, notificationType);
    }

    /**
     * It will validate the API key if its exist and active or not
     * @param apiKeyValidationRequest
     * @return kmsResponse
     */
    public MerchantResponse<String> validatedAPIKey(APIKeyValidationRequest apiKeyValidationRequest) {
        MerchantResponse<String> kmsResponse = kmsClient.validatedMerchantKeys(apiKeyValidationRequest);
        if (MerchantConstant.RESPONSE_SUCCESS == kmsResponse.getStatus() && CollectionUtils.isNotEmpty(kmsResponse.getData())) {
            String mId = kmsResponse.getData().getFirst();
            boolean isMIdExist = merchantInfoDao.isExistsByMIdAndStatus(mId, MerchantStatus.ACTIVE.name());
            if (isMIdExist) {
                return kmsResponse;
            }
            throw new MerchantException(ErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, "Merchant", "MId : " + mId + " is not active."));
        }
        return kmsResponse;
    }
    /**
     * It will fetch the Merchant Encryption keys
     * @param mId
     * @return KMSEncryptionKeysResponse
     */
    public MerchantResponse<KMSEncryptionKeysResponse> getMerchantEncryptionKeys(String mId) {
        return kmsClient.getEncryptionKeys(mId);
    }
    /**
     * It will fetch the keys mapped to MID
     * @param mId,keyType,pageable
     * @return KMSKeyResponse
     */
    public MerchantResponse<KMSKeyResponse> getKeysByMerchant(KeyType keyType, String mId, Pageable pageable) {
        return kmsClient.getKeysByMerchant(keyType, mId, pageable);
    }
    /**
     * It will save the key in DB
     * @param remark,status,keyType,mid
     */
    private UUID saveKey(String mid, KeyType keyType, int status, String remark) {
        KeyManagement keyManagement = KeyManagement.builder().mid(mid).keyType(keyType).status(status == 1).remarks(remark).build();
        return keyRepository.save(keyManagement).getId();
    }

}
package com.epay.merchant.validator;

import com.epay.merchant.dao.MerchantInfoDao;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.enums.MerchantStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.ArrayList;

@RequiredArgsConstructor
@Component
public class KeyValidator extends BaseValidator {

    private final MerchantInfoDao merchantInfoDao;

    /**
     * It will validate the key generation request.
     * MerchantResponse failure and save Login Audit details
     * @param keyGenerationRequest
     */
    public void validateKeyGenerationRequest(KeyGenerationRequest keyGenerationRequest) {
        errorDtoList = new ArrayList<>();
        validatedMandatoryField(keyGenerationRequest);
        validateMId(keyGenerationRequest.getMId());
    }
    /**
     * It will validate API key validation request
     * @param apiKeyValidationRequest
     */
    public void validateAPIKeyValidationRequest(APIKeyValidationRequest apiKeyValidationRequest) {
        errorDtoList = new ArrayList<>();
        validatedMandatoryField(apiKeyValidationRequest);
    }
    /**
     * It will validate the MId
     * @param mId
     */
    public void validateMId(String mId) {
        errorDtoList = new ArrayList<>();
        boolean existsByMIdAndStatus = merchantInfoDao.isExistsByMIdAndStatus(mId, MerchantStatus.ACTIVE.name());
        if (!existsByMIdAndStatus) {
            addError(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Valid MID"));
        }
        throwIfErrors();
    }
    /**
     * It will validate all the mandatory fields present in the request
     * @param keyGenerationRequest
     */
    private void validatedMandatoryField(KeyGenerationRequest keyGenerationRequest) {
        checkMandatoryField(keyGenerationRequest.getMId(), "MId");
        throwIfErrors();
    }
    /**
     * It will validate all the mandatory fields present in the request
     * @param apiKeyValidationRequest
     */
    private void validatedMandatoryField(APIKeyValidationRequest apiKeyValidationRequest) {
        checkMandatoryField(apiKeyValidationRequest.getApiKey(), "ApiKey");
        checkMandatoryField(apiKeyValidationRequest.getApiKeySecret(), "ApiKeySecret");
        throwIfErrors();
    }
}
